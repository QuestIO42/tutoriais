{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Apresenta\u00e7\u00e3o","text":"<p>Neste site voc\u00ea encontrar\u00e1 tutoriais b\u00e1sicos para o desenvolvimento de hardware. Este tema pode ser complexo para muitas pessoas e a documenta\u00e7\u00e3o das ferramentas nem sempre \u00e9 muito organizada. O objetivo aqui n\u00e3o \u00e9 esgotar os assuntos, mas oferecer os primeiros passos aos iniciantes. </p> <p>Presume-se aqui conhecimentos b\u00e1sicos de l\u00f3gica digital e arquitetura de computadores. Se voc\u00ea acha que n\u00e3o tem background suficiente no assunto para come\u00e7ar, d\u00ea uma olhada antes no Curso de L\u00f3gica Digital do Prof. Menotti que inclui tamb\u00e9m um playlist sobre Verilog. </p>"},{"location":"#contribuicoes","title":"Contribui\u00e7\u00f5es","text":"<p>Note</p> <p>Contribui\u00e7\u00f5es para este material s\u00e3o muito bem vindas! </p> <p>As contribui\u00e7\u00f5es podem ser bem pontuais, como pequenas melhorias em algum tutorial ou algum pulo do gato. Para poder nos ajudar com estes tutoriais voc\u00ea s\u00f3 precisa:</p> <ol> <li>Identificar uma contribui\u00e7\u00e3o poss\u00edvel:<ul> <li>Explica\u00e7\u00f5es mais detalhadas sobre algum assunto;</li> <li>Passos intermedi\u00e1rios para melhorar a compreens\u00e3o;</li> <li>Formas alternativas de fazer a mesma coisa; </li> <li>Conte\u00fados mais avan\u00e7ados em cada assunto. </li> </ul> </li> <li>Saber o m\u00ednimo de GitHub para:<ul> <li>Clonar este reposit\u00f3rio;</li> <li>Fazer as modifica\u00e7\u00f5es necess\u00e1rias;</li> <li>Criar um pull request.</li> </ul> </li> <li>Saber o m\u00ednimo de Markdown:<ul> <li>Comece pela sintaxe b\u00e1sica; </li> <li>Veja o fonte de outras partes; </li> <li>Aprenda as particularidades. </li> </ul> </li> </ol>"},{"location":"#referencias","title":"Refer\u00eancias","text":"<p>A seguir est\u00e3o uma lista de refer\u00eancias que voc\u00ea pode usar aprofundar nos conhecimentos:</p> <ul> <li>GitHub</li> <li>Markdown</li> <li>Material for MkDocs</li> </ul>"},{"location":"FPGA/","title":"Kits de FPGAs","text":"<p>Note</p> <p>Neste tutorial est\u00e3o informa\u00e7\u00f5es sobre a tecnologia dos FPGAs, as ferramentas usadas para program\u00e1-los e alguns kits dispon\u00edveis. </p> <p>Um FPGA (Field-Programmable Gate Array) \u00e9 um chip reprogram\u00e1vel que permite implementar circuitos digitais personalizados. Ao contr\u00e1rio de um processador (que executa instru\u00e7\u00f5es), o FPGA configura sua l\u00f3gica interna para se tornar o circuito desejado.</p>"},{"location":"FPGA/#caracteristicas-principais","title":"Caracter\u00edsticas principais:","text":"<ul> <li>Composto por blocos l\u00f3gicos program\u00e1veis e interconex\u00f5es configur\u00e1veis.</li> <li>Pode implementar desde circuitos simples como um contador, uma UART, at\u00e9 sistemas complexos, processadores, aceleradores de IA, etc.</li> <li>\u00c9 reprogram\u00e1vel, voc\u00ea pode alterar a l\u00f3gica quantas vezes quiser, diferente de um ASIC que \u00e9 fixo.</li> </ul>"},{"location":"FPGA/#aplicacoes-comuns","title":"Aplica\u00e7\u00f5es comuns:","text":"<ul> <li>Prototipagem de hardware;</li> <li>Processamento de sinais digitais;</li> <li>Aceleradores de IA, vis\u00e3o computacional e redes;</li> <li>Sistemas embarcados (SoC com processador + l\u00f3gica dedicada).</li> </ul>"},{"location":"FPGA/#fluxo-de-desenvolvimento","title":"Fluxo de desenvolvimento","text":"<p>Em linhas gerais, o desenvolvimento usando FPGAs segue o seguinte fluxo: </p> <pre><code>flowchart LR\n    A[Projeto] --&gt; B([S\u00edntese]);\n    B --&gt; C{Func.\n            correta?};\n    C -- Sim --&gt; D([Implementa\u00e7\u00e3o]);\n    D --&gt; E{Temp. \n            atende?};\n    C -- N\u00e3o --&gt; A;\n    E -- Sim --&gt; F([Programa\u00e7\u00e3o]);\n    E -- Ajustes --&gt; B;\n    E -- Revis\u00e3o --&gt; A;\n    F --&gt; G[Produto];</code></pre> <p>O projeto \u00e9 especificado geralmente em uma HDL, por exemplo, Verilog. Se a s\u00edntese for bem sucedida, \u00e9 poss\u00edvel verificar a opera\u00e7\u00e3o do circuito e saber se ele funciona corretamente, considerando apenas suas entradas e sa\u00eddas, sem se preocupar ainda com a temporiza\u00e7\u00e3o. Esta etapa, chamada de RTL, gera um circuito l\u00f3gico ainda independente da tecnologia alvo. A fase de implementa\u00e7\u00e3o mapeia e roteia o circuito para um dispositivo espec\u00edfico. Ap\u00f3s ela \u00e9 poss\u00edvel saber se os requisitos temporais foram atingidos (e. g. frequ\u00eancia m\u00e1xima). Em caso contr\u00e1rio, ser\u00e1 necess\u00e1rio: (i) ajustar par\u00e2metros de s\u00edntese, incluindo requisitos mais espec\u00edficos; ou (ii) revisar o projeto para otimizar determinadas partes. Um vez que o circuito atende a especifica\u00e7\u00e3o, a programa\u00e7\u00e3o do dispositivo \u00e9 feita diretamente no FPGA (que \u00e9 vol\u00e1til) ou em uma mem\u00f3ria flash que fornecer\u00e1 o bitstream ao FPGA sempre que a placa for ligada. </p> <p>Minicurso</p> <p>O Prof. Menotti ministrou um minicurso sobre o tema, neste link voc\u00ea encontra o material e as grava\u00e7\u00f5es. </p>"},{"location":"FPGA/#ferramentas-de-sintese","title":"Ferramentas de s\u00edntese","text":""},{"location":"FPGA/#quartus","title":"Quartus","text":""},{"location":"FPGA/#vivado","title":"Vivado","text":""},{"location":"FPGA/#yosys","title":"Yosys","text":""},{"location":"FPGA/#kits-de-fpgas_1","title":"Kits de FPGAs","text":"<p>A seguir est\u00e3o alguns dos kits dispon\u00edveis em nosso grupo, mas fique \u00e0 vontade para adicionar outros. </p>"},{"location":"FPGA/#de0-cv-altera","title":"DE0-CV (Altera)","text":""},{"location":"FPGA/#de10-standard-altera","title":"DE10-standard (Altera)","text":""},{"location":"FPGA/#tang-primer-20k-sipeedgowin","title":"Tang Primer 20k (Sipeed/Gowin)","text":""},{"location":"FPGA/#zybo-z7-20-xilinx","title":"Zybo Z7-20 (Xilinx)","text":""},{"location":"HDL/","title":"Linguagens de Descri\u00e7\u00e3o de Hardware (HDL)","text":"<p>Hoje em dia, o projeto de hardware quase n\u00e3o \u00e9 mais feito com diagramas esquem\u00e1ticos, mas com Linguagens de Descri\u00e7\u00e3o de Hardare (HDL<sup>1</sup>). Neste tutorial voc\u00ea vai aprender o b\u00e1sico de Verilog que \u00e9 provavelmente e linguagem mais usada atualmente. Tamb\u00e9m ser\u00e3o usadas linguagens mais modernas, que posteriormente geram Verilog sintetiz\u00e1vel. </p> <ol> <li> <p>Hardware Description Language \u21a9</p> </li> </ol>"},{"location":"RISCV/","title":"RISC-V","text":"<p>Os processadores s\u00e3o hardware de prop\u00f3sito geral, controlados por um programa armazenado na mem\u00f3ria, manipulando dados tamb\u00e9m contidos na mem\u00f3ria. Apesar de serem ineficientes \u2013 se comparados aos circuitos projetados para um prop\u00f3sito espec\u00edfico \u2013 eles s\u00e3o extremamente vers\u00e1teis, pois podemos desenvolver programas para resolver os mais diversos problemas e usar sempre o mesmo hardware para execut\u00e1-los.</p> <p>Um processador softcore \u00e9 aquele que, descrito em uma HDL, pode ser implementado diretamente em um FPGA. Existem muitos cores dispon\u00edveis atualmente. Neste tutorial vamos apresentar algumas ferramentas e primeiros passos de alguns projetos usados no nosso grupo de pesquisa, baseados no processador RISC-V. </p> <p>Os processadores RISC (Reduced Instruction Set Computer) possuem instru\u00e7\u00f5es simples, que s\u00e3o combinadas para executar tarefas mais complexas. O diagrama abaixo fornece uma id\u00e9ia b\u00e1sica de como o RISC-V funciona, segundo algumas premissas: </p> <ul> <li>Instru\u00e7\u00f5es e Dados podem estar na mesma mem\u00f3ria (von Neumann) ou em mem\u00f3rias separadas (Harvard) como no diagrama a seguir.</li> <li>Opera\u00e7\u00f5es l\u00f3gicas e artim\u00e9ticas possuem tr\u00eas operandos em registradores e s\u00e3o executadas na ALU (Arithmetic Logic Unit);<ul> <li>Instru\u00e7\u00f5es do Tipo R recebem dois registradores (<code>rs1</code> e <code>rs2</code>) como entrada e gravam o resultado em um terceiro (<code>rd</code>); </li> <li>Instru\u00e7\u00f5es do Tipo I recebem um registador apenas (<code>rs1</code>) e um imediato codificado na pr\u00f3pria instru\u00e7\u00e3o como entrada. </li> </ul> </li> <li>Instru\u00e7\u00f5es Load / Store s\u00e3o usadas para trazer / levar dados da / para a mem\u00f3ria;</li> </ul> <pre><code>flowchart TD\n    PC[PC] e1@==&gt; |instr. address| IM; \n    e1@{ animate: true }\n    IM[Instructions \n    Memory] ==&gt; |instruction| ID([Instruction Decode]);\n    ID --&gt; |ra1| R;\n    ID --&gt; |ra2| R;\n    ID --&gt; |rd| R;\n    R[Register\n      Bank]\n    ID --&gt; |immediate| E;\n    E@{ shape: manual-input, label: \"extension\"};\n    E ==&gt; MA;\n    ID --&gt; |funct| A\n    R ==&gt; |rs1| A;\n    R ==&gt; |rs2| MA;\n    MA[\\mux/] ==&gt; A[\\ALU/];\n    A ==&gt; |data address| DM[Data \n                       Memory];\n    A ==&gt; |write back| MR;\n    MR[\\mux/] ==&gt; |wd3|R;\n    R ==&gt; |store| DM;\n    DM ==&gt; |load| MR;</code></pre> <p>Seu banco de registadores possui tr\u00eas portas independentes e pode ser implementado da seguinte maneira:</p> <pre><code>module regfile(\n    input clk, we3,            // write enable\n    input [4:0] ra1, ra2, wa3, // rs1, rs2, rd (addr.)\n    input [31:0] wd3,          // rd (data)\n    output [31:0] rd1, rd2);   // rs1, rs2 (data)\n\n  reg [31:0] rf [0:31];\n\n  always@(posedge clk)\n    if (we3) \n       rf[wa3] &lt;= wd3;  \n\n  assign rd1 = (ra1 != 0) ? rf[ra1] : 0;\n  assign rd2 = (ra2 != 0) ? rf[ra2] : 0;\nendmodule\n</code></pre> <p>Note que o registrador 0 (zero) \u00e9 sempre zero, mas nesta implementa\u00e7\u00e3o isso \u00e9 tratado nas leituras ao inv\u00e9s da escrita. </p> <p>Se voc\u00ea quer se aprofundar na constru\u00e7\u00e3o de um processador RISC-V, sugerimos este excelente tutorial do Prof. Bruno Levy.</p>"},{"location":"RISCV/#geradores-de-socs","title":"Geradores de SOCs","text":""},{"location":"RISCV/#chipyard","title":"Chipyard","text":""},{"location":"RISCV/#litex","title":"Litex","text":"<p>O framework LiteX fornece uma infraestrutura integrada para criar SoCs e integrar perif\u00e9ricos. Sendo capaz de criar sistemas completos baseados em FPGA.</p> <pre><code>                                      +---------------+\n                                      |FPGA toolchains|\n                                      +----^-----+----+\n                                           |     |\n                                        +--+-----v--+\n                       +-------+        |           |\n                       | Migen +--------&gt;           |\n                       +-------+        |   LiteX   +\n              +----------------------+  |           |\n              |LiteX Cores Ecosystem +--&gt;           |\n              +----------------------+  +-^-------^-+\n               (Eth, SATA, DRAM, USB,     |       |\n                PCIe, Video, etc...)      +       +\n                                         board   target\n                                         file    file\n</code></pre> <p>O LiteX fornece todos os componentes comuns necess\u00e1rios para criar facilmente um n\u00facleo/SoC FPGA:</p> <ul> <li>Barramentos (Wishbone, AXI, Avalon-ST).</li> <li>N\u00facleos simples: RAM, ROM, Timer, UART, JTAG, etc.</li> <li>N\u00facleos complexos atrav\u00e9s do ecossistema de n\u00facleos: LiteDRAM, LitePCIe, LiteEth, LiteSATA, etc...</li> <li>Suporte a linguagens mistas com recursos de integra\u00e7\u00e3o VHDL/Verilog/Migen/Spinal-HDL/etc...</li> <li>Infraestrutura de depura\u00e7\u00e3o atrav\u00e9s de diversas Bridges ou Litescope.</li> <li>Simula\u00e7\u00e3o simplificada atrav\u00e9s do Verilator.</li> <li>SoC Linux multin\u00facleo baseado em CPU VexRiscv-SMP, LiteDRAM e LiteSATA (https://github.com/litex-hub/linux-on-litex-vexriscv).</li> </ul> <p>Para trabalhar com c\u00f3digos RISC-V \u00e9 preciso compilar a toolchain gnu: <pre><code>git clone https://github.com/riscv/riscv-gnu-toolchain &amp;&amp; cd riscv-gnu-toolchain\nsudo apt-get install autoconf automake autotools-dev curl python3 python3-pip python3-tomli libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev ninja-build git cmake libglib2.0-dev libslirp-dev\n./configure --prefix=/opt/riscv --enable-multilib --enable-newlib --enable-linux --enable-debug-info --with-arch=rv32gc --with-abi=ilp32d\nmake -j $(nproc) &amp;&amp; sudo make install\n</code></pre></p> <p>Para instalar o litex basta criar um python virtual environment e depois executar o script de instala\u00e7\u00e3o: <pre><code>python3 -m venv litex-env\nsource litex-env/bin/activate\npip3 install ninja meson\n</code></pre></p> <p><pre><code>mkdir litex &amp;&amp; cd litex\nwget https://raw.githubusercontent.com/enjoy-digital/litex/master/litex_setup.py\nchmod +x litex_setup.py\n./litex_setup.py --init --install --config standard\n</code></pre> Executando <code>litex_sim --help</code> diversas op\u00e7\u00f5es interessantes podem ser encontradas para configura\u00e7\u00e3o do SoC:</p> <p>Para executar uma simula\u00e7\u00e3o simples com vexriscv vamos instalar as depend\u00eancias, o <code>verilator</code>, <code>sbt</code> e o <code>openjdk</code>. <pre><code>sudo apt install verilator sbt openjdk\n</code></pre></p> <p>Gerar o SoC: <pre><code>litex_sim --integrated-main-ram-size=0x10000 --cpu-type=vexriscv --no-compile-gateware\n</code></pre></p> <p>Para executar um c\u00f3digo simples simulado como exemplo vamos executar o <code>donut</code>: <pre><code>litex_sim --integrated-sram-size=0x2000 --integrated-main-ram-size=0x10000 --cpu-type=vexriscv --cpu-variant=full --no-compile-gateware\nlitex_bare_metal_demo --build-path=build/sim/\nlitex_sim --integrated-sram-size=0x2000 --integrated-main-ram-size=0x10000 --cpu-type=vexriscv --cpu-variant=full --ram-init=demo.bin\n</code></pre></p> <p>Um console como esse ser\u00e1 iniciado o SoC ir\u00e1 executar o c\u00f3digo carregado: <pre><code>        __   _ __      _  __\n       / /  (_) /____ | |/_/\n      / /__/ / __/ -_)&gt;  &lt;\n     /____/_/\\__/\\__/_/|_|\n   Build your hardware, easily!\n\n (c) Copyright 2012-2025 Enjoy-Digital\n (c) Copyright 2007-2015 M-Labs\n\n BIOS built on Sep 21 2025 00:35:41\n BIOS CRC passed (160356a0)\n\n LiteX git sha1: 51e4f2e65\n\n--=============== SoC ==================--\nCPU:            VexRiscv @ 1MHz\nBUS:            wishbone 32-bit @ 4GiB\nCSR:            32-bit data\nROM:            128.0KiB\nSRAM:           8.0KiB\nMAIN-RAM:       64.0KiB\n</code></pre></p> <p>Para execu\u00e7\u00e3o na FPGA vamos usar como exemplo a <code>Tang Primer 20k</code>. O download da toolchain pode ser feito no link: - https://cdn.gowinsemi.com.cn/Gowin_V1.9.11.03_Education_Linux.tar.gz</p> <pre><code>mkdir -p gowin &amp;&amp; cd gowin\nwget https://cdn.gowinsemi.com.cn/Gowin_V1.9.11.03_Education_Linux.tar.gz\ntar -xvf Gowin_V1.9.11.03_Education_Linux.tar.gz\nexport LD_PRELOAD=/usr/lib64/libfreetype.so.6 # ou /lib/x86_64-linux-gnu/libfreetype.so\n</code></pre> <p>Vamos compilar usando o m\u00f3dulo <code>litex-boards</code>, a lista de placas suportadas pode ser encontrada em: - https://github.com/litex-hub/litex-boards</p> <pre><code># python3 -m litex_boards.targets.&lt;board&gt; --help\npython3 -m litex_boards.targets.sipeed_tang_primer_20k --build\nlitex_bare_metal_demo --build-path=build/sipeed_tang_primer_20k/\npython3 -m litex_boards.targets.sipeed_tang_primer_20k --load\n</code></pre> <p>Os c\u00f3digos para serem executados no Core podem ser compilados na \u00e1rvore: - https://github.com/enjoy-digital/litex/tree/master/litex/soc/software/demo</p> <p>E carregados no SoC de variadas formas, vamos usar um exemplo via serial: - https://github.com/enjoy-digital/litex/wiki/Load-Application-Code-To-CPU</p> <pre><code>litex_term /dev/ttyUSBX --kernel=demo.bin\n</code></pre>"},{"location":"RISCV/#cores","title":"Cores","text":""},{"location":"RISCV/#lightriscv","title":"LightRiscv","text":""},{"location":"RISCV/#vexriscv","title":"VexRiscv","text":"<p>O VexRiscv \u00e9 uma implementa\u00e7\u00e3o RISC-V escrita em SpinalHDL, deriva\u00e7\u00e3o do NaxRiscv. Dentre os recursos suportados est\u00e3o:</p> <ul> <li>Conjunto de instru\u00e7\u00f5es RV32I[M][A][F[D]][C].</li> <li>Pipeline de 2 a 5+ est\u00e1gios ([Buscar*X], Decodificar, Executar, [Mem\u00f3ria], [Gravar]).</li> <li>Otimizado para FPGA, n\u00e3o utiliza nenhum bloco IP/primitivo espec\u00edfico do prorpiet\u00e1rio.</li> <li>Otimizado para AXI4, Avalon e wishbone.</li> <li>Extens\u00f5es MUL/DIV opcionais / FPU F32/F64 opcional / MMU opcional.</li> <li>Extens\u00e3o de depura\u00e7\u00e3o opcional que permite a depura\u00e7\u00e3o do Eclipse por meio de uma conex\u00e3o GDB &gt;&gt; openOCD &gt;&gt; JTAG</li> <li>Interrup\u00e7\u00f5es e tratamento de exce\u00e7\u00f5es opcionais com os modos de execu\u00e7\u00e3o [Supervisor] e [Usu\u00e1rio], conforme definido no RISC-V Privileged ISA Especifica\u00e7\u00e3o v1.10.</li> <li>Compat\u00edvel com Linux (SoC: https://github.com/enjoy-digital/linux-on-litex-vexriscv)</li> <li>Ports para Zephyr e FreeRTOS.</li> </ul> <p>Para gerar um core \u00e9 preciso instalar as depend\u00eancias, <code>verilator</code> (3.9+), <code>sbt</code> e o <code>openjdk</code> (8): <pre><code># JAVA JDK 8\nsudo add-apt-repository -y ppa:openjdk-r/ppa\nsudo apt-get update\nsudo apt-get install openjdk-8-jdk -y\nsudo update-alternatives --config java\nsudo update-alternatives --config javac\n\n# Install SBT - https://www.scala-sbt.org/\necho \"deb https://repo.scala-sbt.org/scalasbt/debian all main\" | sudo tee /etc/apt/sources.list.d/sbt.list\necho \"deb https://repo.scala-sbt.org/scalasbt/debian /\" | sudo tee /etc/apt/sources.list.d/sbt_old.list\ncurl -sL \"https://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x2EE0EA64E40A89B84B2DF73499E82A75642AC823\" | sudo apt-key add\nsudo apt-get update\nsudo apt-get install sbt\n\n# Verilator (for sim only, really needs 3.9+, in general apt-get will give you 3.8)\nsudo apt-get install git make autoconf g++ flex bison\ngit clone http://git.veripool.org/git/verilator   # Only first time\nunsetenv VERILATOR_ROOT  # For csh; ignore error if on bash\nunset VERILATOR_ROOT  # For bash\ncd verilator\ngit pull        # Make sure we're up-to-date\ngit checkout v4.216\nautoconf        # Create ./configure script\n./configure\nmake\nsudo make install\n</code></pre></p> <p>Basta agora gerar o SoC: <pre><code>sbt \"runMain vexriscv.demo.GenFull\"\n</code></pre></p> <p>V\u00e1rios cores pr\u00e9-configurados como (Murax, Briey, Linux, GenFull, GenSmallest) podem ser encontrados em: https://github.com/SpinalHDL/VexRiscv/tree/master/src/main/scala/vexriscv/demo</p> <p>Existem v\u00e1rios plugins que podem ser adicionados e criados, alguns exemplos dos que j\u00e1 existem s\u00e3o:</p> <ul> <li>HazardSimplePlugin</li> <li>BranchPlugin</li> <li>MulPlugin</li> <li>DivPlugin</li> <li>CsrPlugin</li> <li>DebugPlugin</li> <li>EmbeddedRiscvJtag</li> <li>FpuPlugin</li> </ul>"},{"location":"RISCV/#naxriscv","title":"NaxRiscv","text":"<p>O NaxRiscv \u00e9 uma implementa\u00e7\u00e3o RISC-V escrita em SpinalHDL. Dentre os recursos suportados est\u00e3o:</p> <ul> <li>Execu\u00e7\u00e3o fora de ordem com renomea\u00e7\u00e3o de registradores.</li> <li>Superscalar (ex: 2 decodificadores, 3 unidades de execu\u00e7\u00e3o, 2 desativadas).</li> <li>(RV32/RV64)IMAFDCSU (Linux/Buildroot funciona em hardware).</li> <li>HDL port\u00e1til, mas FPGA com RAM distribu\u00edda.</li> <li>Elabora\u00e7\u00e3o de hardware descentralizada (n\u00edvel superior vazio parametrizado com plugins).</li> <li>Frontend implementado em torno de uma estrutura de pipeline para facilitar a personaliza\u00e7\u00e3o.</li> <li>MMU com hardware reabastecido (SV32, SV39).</li> <li>Visualiza\u00e7\u00e3o do pipeline por meio de simula\u00e7\u00e3o do Verilator e Konata.</li> <li>Suporte a JTAG / OpenOCD / GDB implementando o RISCV External Debug Support v. 0.13.2</li> </ul> <p>No exemplo que se segue vamos usar o <code>VexRiscv</code> uma deriva\u00e7\u00e3o do <code>NaxRiscv</code>, para isso temos que instalar o <code>verilator</code>, <code>sbt</code> e o <code>openjdk</code>: <pre><code>git clone https://github.com/SpinalHDL/NaxRiscv.git --recursive\ncd NaxRiscv\nexport NAXRISCV=${PWD}\nmake install-toolchain\n</code></pre> Basta configurar a env <code>PATH</code> corretamente e estamos prontos para executar uma simula\u00e7\u00e3o.</p> <p>Para gerar o SoC: <pre><code>export NAXRISCV=${PWD}\n(cd ext/NaxSoftware &amp;&amp; ./init.sh)\n# Generate NaxRiscv\ncd $NAXRISCV\nsbt \"runMain naxriscv.Gen\"\n</code></pre></p> <p>Para executar a simula\u00e7\u00e3o \u00e9 preciso compilar as depend\u00eancias e depois o simulador: <pre><code># Install SDL2, allowing the simulation to display a framebuffer\nsudo apt-get install libsdl2-2.0-0 libsdl2-dev\n\n# Compile the simulator\ncd $NAXRISCV/src/test/cpp/naxriscv\nmake compile\n./obj_dir/VNaxRiscv\n</code></pre></p> <p>Para executar linux em uma simula\u00e7\u00e3o: <pre><code>cd $NAXRISCV/src/test/cpp/naxriscv\nexport LINUX_IMAGES=$NAXRISCV/ext/NaxSoftware/buildroot/images/rv32ima\n./obj_dir/VNaxRiscv \\\n    --load-bin $LINUX_IMAGES/fw_jump.bin,0x80000000 \\\n    --load-bin $LINUX_IMAGES/linux.dtb,0x80F80000 \\\n    --load-bin $LINUX_IMAGES/Image,0x80400000 \\\n    --load-bin $LINUX_IMAGES/rootfs.cpio,0x81000000 \n</code></pre></p>"},{"location":"Sim/","title":"Simula\u00e7\u00f5es e Test Benches","text":"<p>Antes de implementar um circuito em FPGA ou ASIC, \u00e9 fundamental testar seu funcionamento em simula\u00e7\u00e3o. Em Verilog, isso \u00e9 feito usando um test bench, que nada mais \u00e9 do que um c\u00f3digo adicional n\u00e3o sintetiz\u00e1vel, escrito para verificar o m\u00f3dulo que voc\u00ea deseja testar.</p> <p>Considere o seguinte c\u00f3digo para um somador de 4 bits:</p> <pre><code>module adder(\n  input [3:0] a, b,\n  output [4:0] sum);\n  assign sum = a + b;\nendmodule\n</code></pre> <p>Vamos construir um test bench simples para test\u00e1-lo:</p> <ul> <li>O design, tamb\u00e9m chamado de Design Under Test (DUT) ou Unit Under Test (UUT) \u00e9 o circuito que voc\u00ea escreveu;</li> <li>O test bench gera est\u00edmulos (sinais de entrada, como clock, reset, dados) e observa as respostas do DUT;</li> <li>Dessa forma, voc\u00ea pode verificar se o circuito se comporta corretamente antes de gastar tempo e recursos na s\u00edntese e na grava\u00e7\u00e3o em hardware.</li> </ul> <p>Exemplo simples de test bench para um somador:</p> <pre><code>module tb_adder;\n  reg [3:0] a, b;\n  wire [4:0] sum;\n\n  adder uut (.a(a), .b(b), .sum(sum));\n\n  initial begin\n    a = 4'd3; b = 4'd2;\n    #10 a = 4'd7; b = 4'd8;\n    #10 $finish;\n  end\nendmodule\n</code></pre> <p>Aqui o <code>uut</code> (unit under test) recebe valores, e a simula\u00e7\u00e3o permite observar se sum tem o resultado esperado.</p>"},{"location":"Sim/#digitaljs","title":"DigitalJS","text":"<p>Um simulador simples, mas interessante para quem est\u00e1 come\u00e7ando \u00e9 o DigitalJS. Nele voc\u00ea pode interagir gr\u00e1ficamente com o circuito gerado sem a necessidade de criar um test bench. </p>"},{"location":"Sim/#icarus-verilog-iverilog","title":"Icarus Verilog (<code>iverilog</code>)","text":"<p>O Icarus Verilog \u00e9 um simulador Verilog de c\u00f3digo aberto. </p>"},{"location":"Sim/#verilator","title":"Verilator","text":""},{"location":"Verif_Funcionais/","title":"A Import\u00e2ncia da Verifica\u00e7\u00e3o Funcional: Por que testar \u00e9 t\u00e3o crucial quanto projetar","text":"<p>No desenvolvimento de hardware, existe um ditado famoso: \"Se voc\u00ea n\u00e3o o verificou, ele n\u00e3o funciona\".</p> <p>A verifica\u00e7\u00e3o funcional \u00e9 o processo de confirmar que o seu design (o \"Design Under Test\" ou DUT) faz exatamente o que ele foi especificado para fazer, em todas as condi\u00e7\u00f5es poss\u00edveis.</p> <p>Para um projeto de ULA de 32 bits, por exemplo, isso n\u00e3o significa apenas rodar uma simula\u00e7\u00e3o r\u00e1pida para ver se 1+1=2. Significa provar, metodicamente, que o seu design est\u00e1 correto. A import\u00e2ncia disso se resume a tr\u00eas pilares: Custo, Complexidade e Confian\u00e7a.</p>"},{"location":"Verif_Funcionais/#1-o-custo-do-erro","title":"1. O Custo do Erro","text":"<p>Em design de hardware, bugs n\u00e3o s\u00e3o f\u00e1ceis de corrigir.</p> <ul> <li> <p>Em ASICs (Chips Customizados): Um bug funcional encontrado ap\u00f3s a fabrica\u00e7\u00e3o (tape-out) pode custar milh\u00f5es de d\u00f3lares e meses de atraso para um respin (uma nova vers\u00e3o do chip).</p> </li> <li> <p>Em FPGAs: Embora corrig\u00edvel, um bug que chega ao cliente final pode exigir recalls de produtos, atualiza\u00e7\u00f5es de firmware complexas e, o pior de tudo, destruir a reputa\u00e7\u00e3o da sua empresa.</p> </li> </ul> <p>A verifica\u00e7\u00e3o funcional \u00e9 a \"rede de seguran\u00e7a\" que captura esses bugs devastadores antes que eles saiam do ambiente de simula\u00e7\u00e3o.</p>"},{"location":"Verif_Funcionais/#2-o-desafio-da-complexidade-por-que-simular-nao-e-o-bastante","title":"2. O Desafio da Complexidade (Por que \"Simular\" n\u00e3o \u00e9 o bastante)","text":"<p>Um design de 32 bits \u00e9 muito mais complexo do que parece. A ULA em quest\u00e3o tem duas entradas de 32 bits. Isso significa que existem 2\u00b3\u00b2\u00d72\u00b3\u00b2=2\u2076\u2074 combina\u00e7\u00f5es de entrada poss\u00edveis... apenas para a soma.</p> <p>\u00c9 literalmente imposs\u00edvel testar todas as combina\u00e7\u00f5es manualmente (isso levaria bilh\u00f5es de anos).</p> <p>Uma simula\u00e7\u00e3o simples (chamada de happy path ou \"caminho feliz\") pode testar 10+5 ou 100/10. Mas a verifica\u00e7\u00e3o funcional se preocupa com o que acontece nos extremos, os casos de canto (corner cases), que \u00e9 onde 99% dos bugs se escondem.</p>"},{"location":"Verif_Funcionais/#3-o-papel-da-verificacao-confianca-atraves-da-adversidade","title":"3. O Papel da Verifica\u00e7\u00e3o: Confian\u00e7a atrav\u00e9s da Adversidade","text":"<p>A verifica\u00e7\u00e3o funcional muda a mentalidade de \"Como eu mostro que funciona?\" para \"Como eu tento quebrar isso?\".</p> <p>No contexto de um projeto de ULA de 32 bits (unsigned), o ambiente de verifica\u00e7\u00e3o \u00e9 fundamental para levantar e responder quest\u00f5es que um teste simples jamais abordaria:</p> <pre><code>Soma (ADD): O que acontece quando voc\u00ea soma 32'hFFFFFFFF + 32'h1? O resultado deve ser 32'h00000000 e um Carry deve ser gerado. O seu design trata esse carry corretamente? Ou ele simplesmente d\u00e1 um resultado errado?\n\nSubtra\u00e7\u00e3o (SUB): O que acontece em 32'h0 - 32'h1? Isso \u00e9 um underflow. O resultado deve ser 32'hFFFFFFFF e um Borrow (empr\u00e9stimo) deve ser sinalizado. Seu design faz isso?\n\nMultiplica\u00e7\u00e3o (MUL): O que acontece ao multiplicar 32'hFFFFFFFF * 32'hFFFFFFFF? O resultado real tem 64 bits. O seu design trunca o resultado para 32 bits? Ele armazena corretamente os 64 bits (nos registradores Hi e Lo, por exemplo)? Se voc\u00ea n\u00e3o verificar isso, pode estar produzindo resultados massivamente incorretos em multiplica\u00e7\u00f5es grandes sem nem saber.\n\nDivis\u00e3o (DIV): Este \u00e9 o caso cl\u00e1ssico de exce\u00e7\u00e3o. O que acontece se B for zero (A/0)? O design trava? Ele entra em um loop infinito? Ou ele sinaliza um flag de \"Divis\u00e3o por Zero\", como deveria?\n</code></pre>"},{"location":"Verif_Funcionais/#4-o-valor-do-ambiente-de-verificacao","title":"4. O Valor do Ambiente de Verifica\u00e7\u00e3o","text":"<p>A verifica\u00e7\u00e3o funcional n\u00e3o \u00e9 um passo opcional; em muitos projetos, ela consome mais de 70% do tempo total de desenvolvimento.</p> <p>Ter um ambiente de verifica\u00e7\u00e3o permite que voc\u00ea automatize a busca por corner cases. Voc\u00ea pode rodar milh\u00f5es de transa\u00e7\u00f5es aleat\u00f3rias durante a noite e ter a certeza de que seu Golden Model (a \"fonte da verdade\") pegar\u00e1 qualquer discrep\u00e2ncia, garantindo que a ULA que voc\u00ea projetou \u00e9 robusta, correta e pronta para o mundo real.</p>"},{"location":"Verif_Funcionais/#5-mao-na-massa-construindo-um-ambiente-de-verificacao-para-uma-ula-de-32-bits","title":"5. M\u00e3o na Massa: Construindo um Ambiente de Verifica\u00e7\u00e3o para uma ULA de 32 bits","text":"<p>Depois de entender por que a verifica\u00e7\u00e3o \u00e9 a etapa mais cr\u00edtica e demorada no design de hardware, vamos colocar a m\u00e3o na massa. Nesta se\u00e7\u00e3o, construiremos um ambiente de verifica\u00e7\u00e3o completo para uma ULA de 32 bits.</p> <p>Usaremos uma abordagem que combina Cocotb (para simula\u00e7\u00e3o em Python) e pyuvm (uma implementa\u00e7\u00e3o Python da Universal Verification Methodology - UVM).</p> <p>Nosso objetivo \u00e9 criar um testbench automatizado, reutiliz\u00e1vel e auto-verific\u00e1vel que:</p> <ol> <li> <p>Use um DUT (Design Under Test) escrito em Verilog.</p> </li> <li> <p>Defina um plano de verifica\u00e7\u00e3o focado em corner cases.</p> </li> <li> <p>Implemente um Golden Model em Python como nossa \"fonte da verdade\".</p> </li> <li> <p>Use um Sequencer (UVM) para gerar est\u00edmulos (tanto os corner cases quanto milhares de testes aleat\u00f3rios).</p> </li> <li> <p>Use um Scoreboard (UVM) para comparar automaticamente os resultados do DUT com os do Golden Model.</p> </li> <li> <p>Colete Coverage (UVM) para garantir que todos os nossos cen\u00e1rios de teste foram, de fato, executados.</p> </li> </ol>"},{"location":"Verif_Funcionais/#51-dut-design-under-test-a-ula-em-verilog-que-queremos-testar","title":"5.1. DUT (Design Under Test): A ULA em Verilog que queremos testar","text":"<p>O primeiro passo \u00e9 ter o design que queremos testar. O nosso DUT \u00e9 o m\u00f3dulo alu_32_bit escrito em Verilog.</p> <p>\u00c9 fundamental entender que este \u00e9 um modelo educacional simplificado. Ele n\u00e3o \u00e9 uma ULA de n\u00edvel de produ\u00e7\u00e3o. Suas principais caracter\u00edsticas (e limita\u00e7\u00f5es) s\u00e3o:</p> <ul> <li> <p>Opera apenas com n\u00fameros unsigned (sem sinal). Uma ULA real implementaria aritm\u00e9tica de complemento de dois.</p> </li> <li> <p>Possui apenas 4 opera\u00e7\u00f5es b\u00e1sicas, selecionadas pela entrada opcode_in:</p> <ul> <li> <p><code>2'b00</code>: ADD (Soma)</p> </li> <li> <p><code>2'b01</code>: SUB (Subtra\u00e7\u00e3o)</p> </li> <li> <p><code>2'b10</code>: MUL (Multiplica\u00e7\u00e3o)</p> </li> <li> <p><code>2'b11</code>: DIV (Divis\u00e3o)</p> </li> </ul> </li> <li> <p>A Multiplica\u00e7\u00e3o (MUL) produz um resultado de 64 bits, que \u00e9 dividido entre as sa\u00eddas result_out_hi (32 bits mais significativos) e result_out_low (32 bits menos significativos).</p> </li> <li> <p>A Divis\u00e3o (DIV) retorna o Quociente em result_out_low e o Resto (m\u00f3dulo) em result_out_hi.</p> </li> <li> <p>Possui sa\u00eddas de status dedicadas: carry (para estouro de soma), borrow (para estouro de subtra\u00e7\u00e3o) e error_out (especificamente para divis\u00e3o por zero).</p> </li> </ul> <pre><code>module alu_32_bit (\n    input clk,\n    input rst,\n\n    // Entradas\n    input [1:0]  opcode_in, // 00:ADD, 01:SUB, 10:MUL, 11:DIV\n    input [31:0] A_in,\n    input [31:0] B_in,\n\n    // Sa\u00eddas\n    output reg [31:0] result_out_low,\n    output reg [31:0] result_out_hi,\n    output reg carry, // 1 se result_out_low &gt; 0xFFFFFFFF\n    output reg borrow, // 1 se result_out_low &lt; 0\n    output reg error_out  // 1 se B=0 na divis\u00e3o\n);\n\n    // O 'cora\u00e7\u00e3o' da ULA (Implementa\u00e7\u00e3o simplificada)\n    always @(posedge clk) begin\n        if (rst) begin\n            result_out_low &lt;= 32'd0;\n            result_out_hi &lt;= 32'd0;\n            carry &lt;= 1'b0;\n            borrow &lt;= 1'b0;\n            error_out  &lt;= 1'b0;\n        end else begin\n            // Reseta os erros\n            result_out_low &lt;= 32'd0;\n            result_out_hi &lt;= 32'd0;\n            carry &lt;= 1'b0;\n            borrow &lt;= 1'b0;\n            error_out &lt;= 1'b0;\n\n            case (opcode_in)\n                // ADD: {Carry, Soma}\n                2'b00: {carry, result_out_low} &lt;= A_in + B_in;\n\n                // SUB: {Borrow, Subtra\u00e7\u00e3o}\n                2'b01: {borrow, result_out_low} &lt;= A_in - B_in;\n\n                // MUL: Resultado de 64 bits\n                2'b10: {result_out_hi, result_out_low} &lt;= A_in * B_in;\n\n                // DIV: {Resto, Quociente}\n                2'b11: begin\n                    if (B_in == 32'd0) begin\n                        error_out &lt;= 1'b1; // Erro: Divis\u00e3o por zero!\n                        result_out_low &lt;= 32'hX; // Indefinido\n                        result_out_hi &lt;= 32'hX; // Indefinido\n                    end else begin\n                        result_out_low &lt;= A_in / B_in; // Quociente\n                        result_out_hi &lt;= A_in % B_in; // Resto\n                    end\n                end\n\n                default: begin\n                    result_out_low &lt;= 32'hX;\n                    result_out_hi &lt;= 32'hX;\n                end\n            endcase\n        end\n    end\n\nendmodule\n</code></pre>"},{"location":"Verif_Funcionais/#52-tabela-de-verificacao-corner-cases","title":"5.2. Tabela de Verifica\u00e7\u00e3o (Corner Cases)","text":"<p>Antes de escrever qualquer c\u00f3digo de teste, precisamos de um plano de verifica\u00e7\u00e3o. A parte mais importante desse plano \u00e9 identificar os \"casos de canto\" (corner cases) \u2014 os cen\u00e1rios extremos onde os bugs adoram se esconder.</p> <p>Como pensar para montar esta tabela? O processo mental \u00e9:</p> <ol> <li> <p>Limites (Zeros): O que acontece quando as entradas s\u00e3o zero? (0+0, A-A, A*0, 0/B, B/0).</p> </li> <li> <p>Limites (M\u00e1ximos): O que acontece quando as entradas s\u00e3o o valor m\u00e1ximo (0xFFFFFFFF)?</p> </li> <li> <p>Estouros (Overflow/Underflow): O que acontece quando o resultado ultrapassa os 32 bits? (0xFFFFFFFF + 1). O que acontece quando subtra\u00edmos um n\u00famero maior de um menor? (0 - 1).</p> </li> <li> <p>Casos Especiais (Identidades): Quais s\u00e3o as identidades matem\u00e1ticas? (A / 1, A / A).</p> </li> <li> <p>Exce\u00e7\u00f5es (Erros): Quais opera\u00e7\u00f5es s\u00e3o ilegais? (A / 0).</p> </li> </ol> <p>Com base nesse pensamento, foi montada a seguinte tabela de casos de teste direcionados:</p> Opera\u00e7\u00e3o Entradas cr\u00edticas O que verificar Soma <code>0xFFFFFFFF + 1</code> <code>carry = 1</code>, resultado = <code>0</code> Soma <code>0 + 0</code> resultado = <code>0</code> Subtra\u00e7\u00e3o <code>A &lt; B</code> <code>borrow = 1</code> Subtra\u00e7\u00e3o <code>A - A</code> resultado = <code>0</code> Multiplica\u00e7\u00e3o <code>0xFFFFFFFF * 0x2</code> truncamento correto Multiplica\u00e7\u00e3o <code>0xFFFFFFFF * 0xFFFFFFFF</code> bits altos na sa\u00edda HI corretamente Divis\u00e3o <code>x / 0</code> flag ou comportamento definido Divis\u00e3o <code>0 / x</code> resto = <code>0</code>, resultado = <code>0</code> Divis\u00e3o <code>x / 1</code> resto = <code>0</code>, resultado = <code>x</code> Divis\u00e3o <code>x / x</code> resto = <code>0</code>, resultado = <code>1</code> Divis\u00e3o <code>A / B em que A &lt; B</code> resto = <code>A</code>, resultado = <code>0</code> <p>Al\u00e9m desses casos de canto direcionados, tamb\u00e9m geraremos 10.000 est\u00edmulos aleat\u00f3rios. O objetivo dos testes aleat\u00f3rios \u00e9 avaliar o comportamento da ULA em condi\u00e7\u00f5es intermedi\u00e1rias (ex: 273648 * 87263) que nosso c\u00e9rebro n\u00e3o pensaria em testar, garantindo uma cobertura funcional muito mais ampla.</p>"},{"location":"Verif_Funcionais/#53-ambiente-de-verificacao-baseado-na-metodologia-uvm-universal-verification-methodology","title":"5.3. Ambiente de Verifica\u00e7\u00e3o baseado na Metodologia UVM (Universal Verification Methodology)","text":"<p>N\u00e3o vamos construir nosso testbench \"do zero\" ou de forma ad-hoc. Embora os componentes sejam escritos \"na m\u00e3o\" em Python, faremos isso adotando a arquitetura da UVM (Universal Verification Methodology). A UVM \u00e9 o padr\u00e3o da ind\u00fastria para criar ambientes de verifica\u00e7\u00e3o robustos, modulares e reutiliz\u00e1veis.</p> <p>Isso nos d\u00e1 uma arquitetura padronizada com componentes claros: Sequencer (gera dados), Driver (dirige o DUT), Monitor (coleta dados), Scoreboard (verifica dados) e Coverage (mede o progresso).</p> <p>N\u00e3o entraremos nos detalhes profundos da metodologia, pois isso preencheria um curso inteiro. O c\u00f3digo-fonte completo deste ambiente est\u00e1 dispon\u00edvel no reposit\u00f3rio abaixo.</p> <p>Reposit\u00f3rio: https://github.com/MarceloDaEnc/ALU_Verification</p> <p>Vamos analisar os 4 componentes Python mais importantes:</p>"},{"location":"Verif_Funcionais/#531-golden-model","title":"5.3.1. Golden Model","text":"<p>Este \u00e9 o nosso or\u00e1culo, a nossa \"fonte da verdade\". \u00c9 uma fun\u00e7\u00e3o em Python que replica perfeitamente o comportamento esperado da ULA, bit a bit. Note como ele usa m\u00e1scaras (MASK_32) para simular a aritm\u00e9tica de 32 bits do hardware, tratando estouros (carry, borrow) e casos de 64 bits (multiplica\u00e7\u00e3o) exatamente como o Verilog deveria fazer.</p> <p>O Scoreboard usar\u00e1 este modelo para comparar a sa\u00edda do DUT.</p> <pre><code>def alu_32_bit_golden_model(opcode_in, A_in, B_in):\n    MASK_32 = 0xFFFFFFFF\n    A = A_in &amp; MASK_32\n    B = B_in &amp; MASK_32\n\n    # Inicializa\u00e7\u00e3o das sa\u00eddas\n    result_out_low = 0\n    result_out_hi = 0\n    carry = 0\n    borrow = 0\n    error_out = 0\n\n    # ---------------------------------\n    # Simula\u00e7\u00e3o do 'case (opcode_in)'\n    # ---------------------------------\n\n    if opcode_in == 0b00:  # ADD: {carry, result_out_low} &lt;= A_in + B_in\n        full_sum = A + B\n        result_out_low = full_sum &amp; MASK_32\n        carry = (full_sum &gt;&gt; 32) &amp; 1\n\n    elif opcode_in == 0b01:  # SUB: {borrow, result_out_low} &lt;= A_in - B_in\n        result_out_low = (A - B) &amp; MASK_32\n        borrow = 1 if A &lt; B else 0\n\n    elif opcode_in == 0b10:  # MUL: {result_out_hi, result_out_low} &lt;= A_in * B_in\n        full_mul = A * B\n        result_out_low = full_mul &amp; MASK_32\n        result_out_hi = (full_mul &gt;&gt; 32) &amp; MASK_32\n\n    elif opcode_in == 0b11:  # DIV: {Resto, Quociente}\n        if B == 0:\n            # Erro: Divis\u00e3o por zero\n            error_out = 1\n            result_out_low = None \n            result_out_hi = None\n        else:\n            result_out_low = (A // B) &amp; MASK_32\n            result_out_hi = (A % B) &amp; MASK_32\n\n    else:  # default:\n        result_out_low = None\n        result_out_hi = None\n\n    # Retorna um dicion\u00e1rio para facilitar a verifica\u00e7\u00e3o\n    return {\n        \"result_out_low\": result_out_low,\n        \"result_out_hi\": result_out_hi,\n        \"carry\": carry,\n        \"borrow\": borrow,\n        \"error_out\": error_out\n    }\n</code></pre>"},{"location":"Verif_Funcionais/#532-sequencer","title":"5.3.2. Sequencer","text":"<p>O Sequencer \u00e9 o c\u00e9rebro do testbench. Ele \u00e9 respons\u00e1vel por gerar as transa\u00e7\u00f5es de teste (SeqItem) e envi\u00e1-las ao Driver. Nossa sequ\u00eancia principal, ULACoverageSeq, faz duas coisas:</p> <ol> <li> <p>Primeiro, ela envia manualmente (um por um) todos os 11 corner cases que identificamos em nossa tabela de verifica\u00e7\u00e3o.</p> </li> <li> <p>Depois, ela entra em um loop e gera 10.000 transa\u00e7\u00f5es com valores de A, B e opcode totalmente aleat\u00f3rios.</p> </li> </ol> <pre><code>import random\nfrom pyuvm import uvm_sequence\nfrom .seq_item import SeqItem\n\nclass ULACoverageSeq(uvm_sequence):\n    \"\"\"\n    Generates a sequence that covers all bins in CoverageBins.\n    \"\"\"\n    async def body(self):\n\n        item = SeqItem(\"carry_sum\", 4294967295, 1, 0, 0)\n        await self.start_item(item)\n        await self.finish_item(item)\n\n        item = SeqItem(\"sum_of_zeros\", 0, 0, 0, 1)\n        await self.start_item(item)\n        await self.finish_item(item)\n\n        item = SeqItem(\"negative_subtraction\", 0, 1, 1, 2)\n        await self.start_item(item)\n        await self.finish_item(item)\n\n        item = SeqItem(\"self_subtraction\", 10, 10, 1, 3)\n        await self.start_item(item)\n        await self.finish_item(item)\n\n        item = SeqItem(\"mul_truncation\", 4294967295, 2, 2, 4)\n        await self.start_item(item)\n        await self.finish_item(item)\n\n        item = SeqItem(\"mul_full_precision\", 4294967295, 4294967295, 2, 5)\n        await self.start_item(item)\n        await self.finish_item(item)\n\n        item = SeqItem(\"div_by_zero\", 7, 0, 3, 6)\n        await self.start_item(item)\n        await self.finish_item(item)\n\n        item = SeqItem(\"div_zero_numerator\", 0, 10, 3, 7)\n        await self.start_item(item)\n        await self.finish_item(item)\n\n        item = SeqItem(\"div_by_one\", 8, 1, 3, 8)\n        await self.start_item(item)\n        await self.finish_item(item)\n\n        item = SeqItem(\"div_self\", 20, 20, 3, 9)\n        await self.start_item(item)\n        await self.finish_item(item)\n\n        item = SeqItem(\"div_small_numerator\", 10, 20, 3, 10)\n        await self.start_item(item)\n        await self.finish_item(item)\n\n        for _ in range (10000):\n            item = SeqItem(\"random\", random.randint(0, 4294967295), random.randint(0, 4294967295), random.randint(0, 3), 0)\n            await self.start_item(item)\n            await self.finish_item(item)\n</code></pre>"},{"location":"Verif_Funcionais/#533-scoreboard","title":"5.3.3. Scoreboard","text":"<p>O Scoreboard \u00e9 o juiz. Ele recebe as transa\u00e7\u00f5es que foram enviadas ao DUT e tamb\u00e9m os resultados que foram coletados do DUT.</p> <p>Seu trabalho \u00e9, para cada transa\u00e7\u00e3o:</p> <ol> <li> <p>Pegar os dados de entrada (item.opcode, item.A, item.B).</p> </li> <li> <p>Calcular o resultado esperado usando o alu_32_bit_golden_model.</p> </li> <li> <p>Pegar o resultado real que veio do DUT (actual_out_low, actual_out_hi, ...).</p> </li> <li> <p>Comparar os dois.</p> </li> <li> <p>Imprimir PASSED ou FAILED e contar o n\u00famero de falhas.</p> </li> </ol> <p>Ele tamb\u00e9m trata de forma inteligente os valores 'X' (indefinidos) do Verilog, que ocorrem na divis\u00e3o por zero, comparando-os com o None do Python.</p> <pre><code>import cocotb\nfrom pyuvm import *\nfrom .utils import alu_32_bit_golden_model\n\nclass Scoreboard(uvm_component):\n    \"\"\"\n    Compares expected results with actual DUT results.\n    \"\"\"\n    def build_phase(self):\n        self.cmd_fifo = uvm_tlm_analysis_fifo(\"cmd_fifo\", self)\n        self.result_fifo = uvm_tlm_analysis_fifo(\"result_fifo\", self)\n        self.cmd_get_port = uvm_get_port(\"cmd_get_port\", self)\n        self.result_get_port = uvm_get_port(\"result_get_port\", self)\n        self.cmd_export = self.cmd_fifo.analysis_export\n        self.result_export = self.result_fifo.analysis_export\n        self.fail_count = 0\n\n    def connect_phase(self):\n        self.cmd_get_port.connect(self.cmd_fifo.get_export)\n        self.result_get_port.connect(self.result_fifo.get_export)\n\n    async def run_phase(self):\n        while True:\n            item = await self.cmd_get_port.get()\n            (actual_out_low, actual_out_hi, actual_carry, actual_borrow, actual_error) = await self.result_get_port.get()\n            if (actual_out_low == 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' or actual_out_hi == 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' or actual_carry == 'x' or actual_borrow == 'x' or actual_error == 'x'):\n                actual_out_low = actual_out_hi = None\n                actual_carry = 0\n                actual_borrow = 0\n                actual_error = 1\n            else:\n                actual_out_low   = int(actual_out_low)\n                actual_out_hi    = int(actual_out_hi)\n                actual_carry     = int(actual_carry)\n                actual_borrow    = int(actual_borrow)\n                actual_error     = int(actual_error)\n            golden_outputs = alu_32_bit_golden_model(item.opcode, item.A, item.B)\n            if (golden_outputs[\"result_out_low\"] == actual_out_low and golden_outputs[\"result_out_hi\"] == actual_out_hi and golden_outputs[\"carry\"] == actual_carry\n                and golden_outputs[\"borrow\"] == actual_borrow and golden_outputs[\"error_out\"] == actual_error):\n                self.logger.info(f\"\u2705 PASSED: {item}\")\n            else:\n                self.logger.error(f\"\u274c FAILED: {item}\")\n                self.logger.error(\n                    f\"    \u2514\u2500 Expected: Result_Low={golden_outputs[\"result_out_low\"]}, Result_Hi={golden_outputs[\"result_out_hi\"]}, Carry={golden_outputs[\"carry\"]}, Borrow={golden_outputs[\"borrow\"]}, Error={golden_outputs[\"error_out\"]}\\n\"\n                    f\"       Got:      Result_Low={actual_out_low}, Result_Hi={actual_out_hi}, Carry={actual_carry}, Borrow={actual_borrow}, Error={actual_error}\"\n                )\n                self.fail_count += 1\n\n\n    def report_phase(self):\n        \"\"\"Prints a final summary of the test results.\"\"\"\n        cocotb.log.info(f\"\\n+--------------------+\")\n        cocotb.log.info(f\"| Final Fail Count: {self.fail_count:d} |\")\n        cocotb.log.info(f\"+--------------------+\")\n        if self.fail_count &gt; 0:\n            assert False, f\"{self.fail_count} failures detected in scoreboard\"\n</code></pre>"},{"location":"Verif_Funcionais/#534-coverage","title":"5.3.4. Coverage","text":"<p>Este \u00e9 o componente final e crucial. Ele responde \u00e0 pergunta: \"N\u00f3s testamos tudo o que planejamos testar?\".</p> <p>Ele n\u00e3o se importa se o teste passou ou falhou (esse \u00e9 o trabalho do Scoreboard). Ele apenas rastreia quais tipos de transa\u00e7\u00f5es (nossos corner cases) foram executados.</p> <p>Ele \"escuta\" os itens que passam e os adiciona a um set() do Python. No final da simula\u00e7\u00e3o (report_phase), ele compara o set de itens que vimos com a lista CoverageBins de itens que quer\u00edamos ver. Se algum corner case n\u00e3o foi executado, o teste falha, mesmo que todos os outros 10.000 testes aleat\u00f3rios tenham passado.</p> <pre><code>from pyuvm import *\nfrom .seq_item import SeqItem\nfrom .defs import Operation\n\nCoverageBins = [\n    Operation.CARRY_SUM,\n    Operation.SUM_OF_ZEROS,\n    Operation.NEGATIVE_SUBTRACTION,\n    Operation.SELF_SUBTRACTION,\n    Operation.MUL_TRUNCATION,\n    Operation.MUL_FULL_PRECISION,\n    Operation.DIV_ZERO_NUMERATOR,\n    Operation.DIV_BY_ZERO,\n    Operation.DIV_BY_ONE,\n    Operation.DIV_SELF,\n    Operation.DIV_SMALLER_NUMERATOR\n]\n\nclass Coverage(uvm_subscriber):\n    \"\"\"\n    Collects and verifies functional coverage for the PIE environment.\n    \"\"\"\n    def end_of_elaboration_phase(self):\n        self.cvg = set()\n\n    def write(self, item):\n        if isinstance(item, SeqItem):\n            coverage_bin = (\n                item.type\n            )\n            self.cvg.add(coverage_bin)\n\n    def report_phase(self):\n        try:\n            disable_errors = ConfigDB().get(self, \"\", \"DISABLE_COVERAGE_ERRORS\")\n        except UVMConfigItemNotFound:\n            disable_errors = False\n\n        if not disable_errors:\n            coverage_bins_set = set(CoverageBins)\n            missed_bins = coverage_bins_set - self.cvg\n            if len(missed_bins) &gt; 0:\n                self.logger.error(\"Functional coverage error!\")\n                self.logger.error(f\"  -&gt; Bins not covered: {missed_bins}\")\n                assert False\n            else:\n                self.logger.info(\"\u2705 Functional coverage reached all bins.\")\n                assert True\n</code></pre>"},{"location":"Verif_Funcionais/#54-resultados","title":"5.4. Resultados","text":"<p>A execu\u00e7\u00e3o do ambiente de verifica\u00e7\u00e3o gera logs detalhados, como mostra o snippet abaixo. Podemos ver o Scoreboard validando com \u2705 PASSED cada uma das 10.011 transa\u00e7\u00f5es (os 11 corner cases e as 10.000 aleat\u00f3rias), o Coverage reportando que todos os bins (casos de canto) foram atingidos, e o sum\u00e1rio final do cocotb indicando Final Fail Count: 0.</p> <pre><code>5200780.00ns INFO     ..ULA/components/scoreboard.py(40) [uvm_test_top.env.scoreboard]: \u2705 PASSED: A: 0x696B5381 | B: 0x1663E737 | OpCode: 0     \n5201300.00ns INFO     ..ULA/components/scoreboard.py(40) [uvm_test_top.env.scoreboard]: \u2705 PASSED: A: 0x984E1486 | B: 0x7CD362B5 | OpCode: 3     \n5201820.00ns INFO     ..ULA/components/scoreboard.py(40) [uvm_test_top.env.scoreboard]: \u2705 PASSED: A: 0xF86AFB3C | B: 0xE33138D6 | OpCode: 2     \n5202340.00ns INFO     ..ULA/components/scoreboard.py(40) [uvm_test_top.env.scoreboard]: \u2705 PASSED: A: 0xF096B0F8 | B: 0xE1B58BD  | OpCode: 2     \n5202860.00ns INFO     ..ULA/components/scoreboard.py(40) [uvm_test_top.env.scoreboard]: \u2705 PASSED: A: 0xF0AAF75D | B: 0xF587E1D9 | OpCode: 1     \n5203380.00ns INFO     ..ULA/components/scoreboard.py(40) [uvm_test_top.env.scoreboard]: \u2705 PASSED: A: 0x1D81C37B | B: 0xA7DDF220 | OpCode: 0     \n5203900.00ns INFO     ..ULA/components/scoreboard.py(40) [uvm_test_top.env.scoreboard]: \u2705 PASSED: A: 0x9908E520 | B: 0x16818DDC | OpCode: 3     \n5204420.00ns INFO     ..ULA/components/scoreboard.py(40) [uvm_test_top.env.scoreboard]: \u2705 PASSED: A: 0x1494B710 | B: 0xEBEBBA8C | OpCode: 2     \n5204940.00ns INFO     ..ULA/components/scoreboard.py(40) [uvm_test_top.env.scoreboard]: \u2705 PASSED: A: 0x54CBDF2  | B: 0xE4378B68 | OpCode: 3     \n5205460.00ns INFO     ..ULA/components/scoreboard.py(40) [uvm_test_top.env.scoreboard]: \u2705 PASSED: A: 0x738B957A | B: 0x1B4552B4 | OpCode: 0     \n5205980.00ns INFO     ..ULA/components/scoreboard.py(40) [uvm_test_top.env.scoreboard]: \u2705 PASSED: A: 0x6F26EB06 | B: 0x7EB17FA6 | OpCode: 3     \n5206500.00ns INFO     ..ULA/components/scoreboard.py(40) [uvm_test_top.env.scoreboard]: \u2705 PASSED: A: 0x2D9E521A | B: 0x2687A9F  | OpCode: 1     \n5207020.00ns INFO     ..ULA/components/scoreboard.py(40) [uvm_test_top.env.scoreboard]: \u2705 PASSED: A: 0x909AC5DA | B: 0xAE02F006 | OpCode: 2     \n5207540.00ns INFO     ..ULA/components/scoreboard.py(40) [uvm_test_top.env.scoreboard]: \u2705 PASSED: A: 0xFF926233 | B: 0xA8DE4009 | OpCode: 0     \n5307540.00ns INFO     ..M_ULA/components/coverage.py(47) [uvm_test_top.env.coverage]: \u2705 Functional coverage reached all bins.\n5307540.00ns INFO     cocotb                             \n                                                         +--------------------+\n5307540.00ns INFO     cocotb                             | Final Fail Count: 0 |\n5307540.00ns INFO     cocotb                             +--------------------+\n5307540.00ns INFO     cocotb.regression                  ULATest passed\n5307540.00ns INFO     cocotb.regression                  **************************************************************************************\n                                                         ** TEST                          STATUS  SIM TIME (ns)  REAL TIME (s)  RATIO (ns/s) **\n                                                         **************************************************************************************\n                                                         ** tests.test_ULA.ULATest         PASS     5307540.00           6.77     784140.29  **\n                                                         **************************************************************************************\n                                                         ** TESTS=1 PASS=1 FAIL=0 SKIP=0            5307540.00           6.82     778361.96  **\n                                                         **************************************************************************************\n</code></pre> <p>Al\u00e9m da sa\u00edda de log, a simula\u00e7\u00e3o tamb\u00e9m gera um arquivo alu_32_bit.fst. Este arquivo de waveform (forma de onda) permite uma inspe\u00e7\u00e3o visual ciclo-a-ciclo do comportamento do DUT.</p> <p>Para analisar visualmente os corner cases (e qualquer outra transa\u00e7\u00e3o), provando que o DUT se comportou exatamente como o Golden Model previu, o arquivo alu_32_bit.fst pode ser acessado no reposit\u00f3rio do projeto e aberto usando um visualizador de waveforms gratuito, como o GtkWave.</p>"},{"location":"Verif_Funcionais/#consideracoes-finais","title":"Considera\u00e7\u00f5es Finais","text":"<p>Nesta jornada, passamos da filosofia da verifica\u00e7\u00e3o (\"Por que testar?\") para a pr\u00e1tica (\"Como testar?\"). Constru\u00edmos um ambiente de verifica\u00e7\u00e3o robusto e moderno usando Python, Cocotb e a metodologia UVM.</p> <p>Os pilares deste ambiente foram:</p> <ol> <li> <p>Um Golden Model em Python, que atua como a \"fonte da verdade\" inquestion\u00e1vel.</p> </li> <li> <p>Um Sequencer que combina testes direcionados (os corner cases) com a for\u00e7a bruta de milhares de testes aleat\u00f3rios.</p> </li> <li> <p>Um Scoreboard automatizado, que atua como um juiz incans\u00e1vel, comparando o DUT com o Golden Model a cada ciclo.</p> </li> <li> <p>Uma medi\u00e7\u00e3o de Coverage, que garante que n\u00e3o apenas testamos muito, mas que testamos as coisas certas.</p> </li> </ol> <p>Ao rodar mais de 10.000 testes e focar especificamente nos pontos de falha (overflow, underflow, divis\u00e3o por zero, limites de 64 bits), alcan\u00e7amos um n\u00edvel de confian\u00e7a no design que seria imposs\u00edvel de obter com simula\u00e7\u00f5es manuais simples.</p> <p>Isso demonstra o princ\u00edpio central da verifica\u00e7\u00e3o: n\u00e3o basta provar que o design funciona no \"caminho feliz\"; \u00e9 preciso provar, metodicamente, que ele n\u00e3o falha em nenhum dos milhares de \"caminhos infelizes\". S\u00f3 ent\u00e3o podemos afirmar que o design est\u00e1, de fato, correto.</p>"},{"location":"spinalHDL/","title":"Tutorial SpinalHDL","text":"<p>Nota</p> <p>Este tutorial \u00e9 uma introdu\u00e7\u00e3o ao SpinalHDL, uma linguagem de descri\u00e7\u00e3o de hardware baseada em Scala. Ele cobre os conceitos b\u00e1sicos, principais caracter\u00edsticas e fornece exemplos pr\u00e1ticos para ajudar os iniciantes a come\u00e7ar a usar o SpinalHDL em seus projetos de design de hardware.</p>"},{"location":"spinalHDL/#introducao-ao-spinalhdl","title":"Introdu\u00e7\u00e3o ao SpinalHDL","text":"<p>SpinalHDL \u00e9 uma linguagem de descri\u00e7\u00e3o de hardware (HDL) baseada em Scala, projetada para facilitar o desenvolvimento de circuitos digitais complexos. Ela combina a expressividade e a flexibilidade do Scala com conceitos espec\u00edficos de design de hardware, permitindo que os engenheiros criem designs mais rapidamente e com menos erros.</p> <p>Foi criada por Christophe de Dinechin, um engenheiro de hardware e software com vasta experi\u00eancia em design de circuitos digitais. O SpinalHDL \u00e9 mantido pela SpinalCom, uma empresa especializada em solu\u00e7\u00f5es de design de hardware. O motivo para a cria\u00e7\u00e3o do SpinalHDL foi a necessidade de uma linguagem de descri\u00e7\u00e3o de hardware mais moderna e eficiente, que pudesse aproveitar os avan\u00e7os na programa\u00e7\u00e3o funcional e orientada a objetos oferecidos pelo Scala. O SpinalHDL \u00e9 amplamente utilizado em projetos de design de hardware, especialmente em aplica\u00e7\u00f5es que exigem alta performance e flexibilidade, como FPGAs e ASICs.</p> <p>Aplica\u00e7\u00f5es criadas com SpinalHDL incluem processadores personalizados, controladores de mem\u00f3ria, interfaces de comunica\u00e7\u00e3o e sistemas embarcados. Como exemplos de projetos not\u00e1veis, podemos citar o VexRiscv, um processador RISC-V open-source.</p>"},{"location":"spinalHDL/#informacoes-adicionais","title":"Informa\u00e7\u00f5es Adicionais","text":"<ul> <li>Documenta\u00e7\u00e3o Oficial do SpinalHDL</li> <li>Reposit\u00f3rio no GitHub</li> </ul>"},{"location":"spinalHDL/#preparando-o-ambiente-de-desenvolvimento","title":"Preparando o Ambiente de Desenvolvimento","text":"<p>Para instalar o SpinalHDL, voc\u00ea precisar\u00e1 ter o Scala e o SBT (Scala Build Tool) instalados em sua m\u00e1quina. Siga os passos abaixo:</p> <ol> <li>Instale o Scala: Voc\u00ea pode baixar o Scala do site oficial scala-lang.org. Siga as instru\u00e7\u00f5es de instala\u00e7\u00e3o para o seu sistema operacional.</li> <li>Instale o SBT: O SBT \u00e9 a ferramenta de build para projetos Scala. Voc\u00ea pode baixar o SBT do site oficial sbt. Siga as instru\u00e7\u00f5es de instala\u00e7\u00e3o para o seu sistema operacional.</li> <li>Crie um novo projeto SBT: Abra um terminal e crie um novo diret\u00f3rio para o seu projeto. Navegue at\u00e9 esse diret\u00f3rio e execute o comando <code>sbt new scala/scala-seed.g8</code> para criar um novo projeto Scala. SBT \u00e9 a ferramenta padr\u00e3o para construir projetos Scala, e usar um projeto SBT permite que voc\u00ea facilmente adicione o SpinalHDL como uma depend\u00eancia, gerencie vers\u00f5es e compile seu c\u00f3digo de forma eficiente.</li> <li>Adicione a depend\u00eancia do SpinalHDL: No arquivo <code>build.sbt</code> do seu projeto, adicione a seguinte linha para incluir o SpinalHDL como depend\u00eancia:    <pre><code>libraryDependencies += \"com.github.spinalhdl\" %% \"spinalhdl-core\" % \"1.8.0\"\n</code></pre></li> <li> <p>Atualize o projeto: No terminal, dentro do diret\u00f3rio do seu projeto, execute o comando <code>sbt update</code> para baixar as depend\u00eancias do SpinalHDL.    </p> </li> <li> <p>Verifique a instala\u00e7\u00e3o: Crie um arquivo Scala simples para testar se o SpinalHDL est\u00e1 funcionando corretamente. Dentro da pasta <code>src/main/scala</code>, crie um arquivo <code>MeuModulo.scala</code> com o seguinte conte\u00fado:    <pre><code>import spinal.core._\n\nclass MeuModulo extends Component {\n  val entrada = in Bool()\n  val saida = out Bool()\n\n  saida := entrada\n}\n\nobject MeuModuloVerilog {\n  def main(args: Array[String]): Unit = {\n    SpinalVerilog(new MeuModulo)\n  }\n}\n</code></pre>    Execute o comando <code>sbt run</code> no terminal. Se tudo estiver configurado corretamente, o SpinalHDL gerar\u00e1 o c\u00f3digo Verilog para o m\u00f3dulo <code>MeuModulo</code>.</p> </li> </ol>"},{"location":"spinalHDL/#fundamentos-da-sintaxe","title":"Fundamentos da Sintaxe","text":"<p>A sintaxe do SpinalHDL \u00e9 baseada em Scala, o que significa que voc\u00ea pode usar todas as funcionalidades da linguagem Scala ao escrever seu c\u00f3digo de hardware. Aqui est\u00e3o alguns conceitos b\u00e1sicos da sintaxe do SpinalHDL:</p> <ol> <li>Componentes: Em SpinalHDL, um componente \u00e9 uma unidade b\u00e1sica de design de hardware. Voc\u00ea define um componente criando uma classe que estende a classe <code>Component</code>.    <pre><code>class MeuComponente extends Component {\n  // Defini\u00e7\u00e3o do componente\n}\n</code></pre></li> <li>Portas: As portas de um componente s\u00e3o definidas usando os m\u00e9todos <code>in</code> e <code>out</code>. Voc\u00ea pode definir portas de entrada e sa\u00edda para o seu componente.    <pre><code>val entrada = in Bool()  // Porta de entrada do tipo booleano\nval saida = out Bool()   // Porta de sa\u00edda do tipo booleano\n</code></pre></li> <li>Tipos B\u00e1sicos: SpinalHDL suporta v\u00e1rios tipos de dados, incluindo <code>Bool</code>, <code>UInt</code>, <code>SInt</code>, e <code>Bits</code>. Voc\u00ea pode especificar a largura dos tipos inteiros usando o m\u00e9todo <code>bits</code>.    <pre><code>val meuUInt = UInt(8 bits)  // Inteiro sem sinal de 8 bits\nval meuSInt = SInt(16 bits) // Inteiro com sinal de 16 bits\nval meuBits = Bits(4 bits)  // Vetor de bits de 4 bits\n</code></pre></li> <li>Atribui\u00e7\u00f5es: As atribui\u00e7\u00f5es em SpinalHDL s\u00e3o feitas usando o operador <code>:=</code>. Voc\u00ea pode atribuir valores \u00e0s portas e sinais dentro do seu componente.    <pre><code>saida := entrada  // Atribui o valor da entrada \u00e0 sa\u00edda\n</code></pre> O operador <code>=</code> \u00e9 usado para atribui\u00e7\u00f5es de valor em vari\u00e1veis, enquanto <code>:=</code> \u00e9 usado para atribui\u00e7\u00f5es em circuitos digitais, onde a ordem das opera\u00e7\u00f5es e a propaga\u00e7\u00e3o de sinais s\u00e3o importantes. O uso de <code>:=</code> deixa claro que estamos lidando com l\u00f3gica de hardware, onde as atribui\u00e7\u00f5es podem ser sens\u00edveis ao tempo e \u00e0 ordem de execu\u00e7\u00e3o.</li> <li>Bundles: Bundles s\u00e3o usados para agrupar v\u00e1rias portas ou sinais em uma \u00fanica unidade. Voc\u00ea pode definir um Bundle criando uma classe que estende a classe <code>Bundle</code>.    <pre><code>class MeuBundle extends Bundle {\n  val sinal1 = Bool()\n  val sinal2 = UInt(8 bits)\n}\n</code></pre>     Exemplo de um m\u00f3dulo simples usando Bundle:     <pre><code>import spinal.core._\nclass MeuModuloComBundle extends Component {\nval io = new Bundle {\n    val entrada_sinal1 = in Bool()\n    val entrada_sinal2 = in UInt(8 bits)\n    val saida_sinal1 = out Bool()\n    val saida_sinal2 = out UInt(8 bits)\n}\n\nio.saida_sinal1 := io.entrada_sinal1\nio.saida_sinal2 := io.entrada_sinal2\n}\n</code></pre></li> <li>Controle de Fluxo: SpinalHDL suporta estruturas de controle de fluxo como <code>if</code>, <code>else</code>, <code>while</code>, e <code>for</code>, permitindo que voc\u00ea crie l\u00f3gica condicional e loops em seu design.    <pre><code>when(entrada) {\n  saida := True\n} otherwise {\n  saida := False\n}\n</code></pre></li> <li>Sinais: Sinais intermedi\u00e1rios podem ser declarados usando <code>val</code> ou <code>var</code>, dependendo se o valor \u00e9 constante ou vari\u00e1vel.    <pre><code>val sinalIntermediario = Bool()\nsinalIntermediario := entrada &amp; True\n</code></pre></li> <li>Clock e Reset: Voc\u00ea pode definir sinais de clock e reset usando <code>ClockDomain</code> e <code>Reset</code>. Isso \u00e9 \u00fatil para designs s\u00edncronos.    <pre><code>val clock = ClockDomain.current.clock\nval reset = ClockDomain.current.reset\n</code></pre></li> <li>Mem\u00f3rias: SpinalHDL oferece suporte para a cria\u00e7\u00e3o de mem\u00f3rias, como RAM e ROM, usando classes espec\u00edficas.    <pre><code>val ram = Mem(UInt(8 bits), 256) // RAM de 256x8 bits\n</code></pre></li> <li>Hierarquia de modulos: Voc\u00ea pode instanciar outros componentes dentro de um componente para criar hierarquias de design.     <pre><code>val meuOutroComponente = new MeuOutroComponente()\n</code></pre></li> </ol>"},{"location":"spinalHDL/#criando-os-primeiros-modulos","title":"Criando os Primeiros M\u00f3dulos","text":""},{"location":"spinalHDL/#adder-parametrizavel-simples","title":"Adder Parametrizavel Simples","text":"SpinalHDLVerilog <pre><code>import spinal.core._\n\nclass AdderParametrizavel(val largura: Int) extends Component {\n  val io = new Bundle {\n    val a = in UInt(largura bits)\n    val b = in UInt(largura bits)\n    val soma = out UInt(largura bits)\n  }\n\n  io.soma := io.a + io.b\n}\n</code></pre> <pre><code>module AdderParametrizavel #(\n  parameter LARGURA = 8  // Par\u00e2metro para largura\n)(\n  input  wire [LARGURA-1:0] a,\n  input  wire [LARGURA-1:0] b,\n  output wire [LARGURA-1:0] soma\n);\n\n  assign soma = a + b;\n\nendmodule\n</code></pre> <ul> <li> <p><code>class AdderParametrizavel(val largura: Int) extends Component</code>: Define um componente chamado <code>AdderParametrizavel</code> que \u00e9 parametrizado pela largura dos sinais de entrada e sa\u00edda.</p> </li> <li> <p><code>val io = new Bundle { ... }</code>: Cria um bundle de entradas e sa\u00eddas para o componente.</p> </li> <li> <p><code>io.soma := io.a + io.b</code>: Define a l\u00f3gica do somador, que \u00e9 a soma das entradas <code>a</code> e <code>b</code>.</p> </li> </ul>"},{"location":"spinalHDL/#ula-simples","title":"ULA Simples","text":"SpinalHDLVerilog <pre><code>import spinal.core._\nclass UlaSimples(val largura: Int) extends Component {\n  val io = new Bundle {\n    val a = in UInt(largura bits)\n    val b = in UInt(largura bits)\n    val operacao = in UInt(2 bits) // 00: add, 01: sub, 10: and, 11: or\n    val resultado = out UInt(largura bits)\n  }\n\n  io.resultado := 0.U // Funciona como valor padr\u00e3o\n\n  switch(io.operacao) {\n    is(0.U) { io.resultado := io.a + io.b } // Adi\u00e7\u00e3o\n    is(1.U) { io.resultado := io.a - io.b } // Subtra\u00e7\u00e3o\n    is(2.U) { io.resultado := io.a &amp; io.b } // AND\n    is(3.U) { io.resultado := io.a | io.b } // OR\n  }\n}\n</code></pre> <pre><code>module UlaSimples #(\n  parameter LARGURA = 8  // Par\u00e2metro para largura\n)(\n  input  wire [LARGURA-1:0] a,\n  input  wire [LARGURA-1:0] b,\n  input  wire [1:0] operacao,\n  output reg  [LARGURA-1:0] resultado\n);\n\nalways @(*) begin\n  case (operacao)\n    2'b00: resultado = a + b; // Adi\u00e7\u00e3o\n    2'b01: resultado = a - b; // Subtra\u00e7\u00e3o\n    2'b10: resultado = a &amp; b; // AND\n    2'b11: resultado = a | b; // OR\n    default: resultado = 0;\n  endcase\nend\n\nendmodule\n</code></pre> <ul> <li> <p><code>class UlaSimples(val largura: Int) extends Component</code>: Define um componente chamado <code>UlaSimples</code> que \u00e9 parametrizado pela largura dos sinais de entrada e sa\u00edda.</p> </li> <li> <p><code>val io = new Bundle { ... }</code>: Cria um bundle de entradas e sa\u00eddas para o componente.</p> </li> <li> <p><code>switch(io.operacao) { ... }</code>: Implementa a l\u00f3gica da ULA, realizando diferentes opera\u00e7\u00f5es com base no valor da entrada <code>operacao</code>.</p> </li> </ul>"},{"location":"spinalHDL/#registrador-com-enable-e-reset","title":"Registrador com Enable e Reset","text":"SpinalHDLVerilog <pre><code>import spinal.core._\n\nclass RegistradorComEnableReset(val largura: Int) extends Component {\n  val io = new Bundle {\n    val d = in UInt(largura bits)\n    val clk = in Bool()\n    val reset = in Bool()\n    val enable = in Bool()\n    val q = out UInt(largura bits)\n  }\n\n  io.q := 0.U\n\n  when(io.reset) {\n    io.q := 0.U\n  } .elsewhen(io.enable) {\n    io.q := io.d\n  }\n}\n</code></pre> <pre><code>module RegistradorComEnableReset #(\n  parameter LARGURA = 8  // Par\u00e2metro para largura\n)(\n  input  wire [LARGURA-1:0] d,\n  input  wire clk,\n  input  wire reset,\n  input  wire enable,\n  output reg  [LARGURA-1:0] q\n);\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    q &lt;= 0;\n  end else if (enable) begin\n    q &lt;= d;\n  end\nend\n\nendmodule\n</code></pre> <ul> <li> <p><code>class RegistradorComEnableReset(val largura: Int) extends Component</code>: Define um componente chamado <code>RegistradorComEnableReset</code> que \u00e9 parametrizado pela largura dos sinais de entrada e sa\u00edda.</p> </li> <li> <p><code>val io = new Bundle { ... }</code>: Cria um bundle de entradas e sa\u00eddas para o componente.</p> </li> <li> <p><code>when(io.reset) { ... } .elsewhen(io.enable) { ... }</code>: Implementa a l\u00f3gica do registrador, que pode ser resetado ou atualizado com o valor de <code>d</code> quando <code>enable</code> est\u00e1 ativo.</p> </li> </ul>"},{"location":"spinalHDL/#criando-maquina-de-estados-finitos-fsm","title":"Criando Maquina de Estados Finitos (FSM)","text":"<p>A maquina de estados apresenta 6 estados (A, B, C, D, E, F) e 3 entradas de controle (start, stop, back). A transi\u00e7\u00e3o entre os estados \u00e9 controlada pelas entradas de controle da seguinte forma: 001 (start) move para o pr\u00f3ximo estado, 010 ou 011 (stop) mant\u00e9m o estado atual, e 100 (back) retorna ao estado anterior. A sa\u00edda da FSM \u00e9 o estado atual representado por um n\u00famero de 3 bits (1 a 6).</p> SpinalHDLVerilog <pre><code>import spinal.core._\n\nclass FsmABCF extends Component {\n  val io = new Bundle {\n    val ctrl   = in UInt(3 bits)   // sinal de controle\n    val estado = out UInt(3 bits)  // sa\u00edda (1..6)\n  }\n\n  // Registrador de estado, inicia no A (1)\n  val estadoReg = RegInit(U(1, 3 bits))\n\n  switch(estadoReg) {\n    is(U(1)) { // Estado A\n      when(io.ctrl === U\"3'b001\") { estadoReg := U(2) }   // start -&gt; B\n      when(io.ctrl === U\"3'b100\") { estadoReg := U(1) }   // back -&gt; fica em A\n    }\n    is(U(2)) { // Estado B\n      when(io.ctrl === U\"3'b001\") { estadoReg := U(3) }   // start -&gt; C\n      when(io.ctrl === U\"3'b100\") { estadoReg := U(1) }   // back -&gt; A\n    }\n    is(U(3)) { // Estado C\n      when(io.ctrl === U\"3'b001\") { estadoReg := U(4) }   // start -&gt; D\n      when(io.ctrl === U\"3'b100\") { estadoReg := U(2) }   // back -&gt; B\n    }\n    is(U(4)) { // Estado D\n      when(io.ctrl === U\"3'b001\") { estadoReg := U(5) }   // start -&gt; E\n      when(io.ctrl === U\"3'b100\") { estadoReg := U(3) }   // back -&gt; C\n    }\n    is(U(5)) { // Estado E\n      when(io.ctrl === U\"3'b001\") { estadoReg := U(6) }   // start -&gt; F\n      when(io.ctrl === U\"3'b100\") { estadoReg := U(4) }   // back -&gt; D\n    }\n    is(U(6)) { // Estado F\n      when(io.ctrl === U\"3'b001\") { estadoReg := U(6) }   // j\u00e1 \u00e9 o \u00faltimo, fica\n      when(io.ctrl === U\"3'b100\") { estadoReg := U(5) }   // back -&gt; E\n    }\n  }\n\n  // stop (010 ou 011) = n\u00e3o faz nada -&gt; mant\u00e9m estado\n  io.estado := estadoReg\n}\n</code></pre> <pre><code>module FsmABCF (\n    input  wire       clk,\n    input  wire       reset,    // reset s\u00edncrono\n    input  wire [2:0] ctrl,     // 001=start, 010/011=stop, 100=back\n    output reg  [2:0] estado\n);\n\n  // Defini\u00e7\u00e3o dos estados (codifica\u00e7\u00e3o bin\u00e1ria simples)\n  localparam A = 3'b001;\n  localparam B = 3'b010;\n  localparam C = 3'b011;\n  localparam D = 3'b100;\n  localparam E = 3'b101;\n  localparam F = 3'b110;\n\n  // Registrador de estado\n  reg [2:0] estado_reg, estado_next;\n\n  // L\u00f3gica de transi\u00e7\u00e3o combinacional\n  always @(*) begin\n    estado_next = estado_reg; // padr\u00e3o = mant\u00e9m\n    case (estado_reg)\n      A: begin\n        if (ctrl == 3'b001) estado_next = B; // start -&gt; B\n        else if (ctrl == 3'b100) estado_next = A; // back -&gt; fica\n      end\n      B: begin\n        if (ctrl == 3'b001) estado_next = C; // start -&gt; C\n        else if (ctrl == 3'b100) estado_next = A; // back -&gt; A\n      end\n      C: begin\n        if (ctrl == 3'b001) estado_next = D; // start -&gt; D\n        else if (ctrl == 3'b100) estado_next = B; // back -&gt; B\n      end\n      D: begin\n        if (ctrl == 3'b001) estado_next = E; // start -&gt; E\n        else if (ctrl == 3'b100) estado_next = C; // back -&gt; C\n      end\n      E: begin\n        if (ctrl == 3'b001) estado_next = F; // start -&gt; F\n        else if (ctrl == 3'b100) estado_next = D; // back -&gt; D\n      end\n      F: begin\n        if (ctrl == 3'b001) estado_next = F; // j\u00e1 \u00e9 o \u00faltimo\n        else if (ctrl == 3'b100) estado_next = E; // back -&gt; E\n      end\n      default: estado_next = A; // seguran\u00e7a\n    endcase\n  end\n\n  // Atualiza\u00e7\u00e3o do estado (flip-flop com reset s\u00edncrono)\n  always @(posedge clk) begin\n    if (reset)\n      estado_reg &lt;= A;\n    else\n      estado_reg &lt;= estado_next;\n  end\n\n  // Sa\u00edda = estado atual\n  always @(*) begin\n    estado = estado_reg;\n  end\n\nendmodule\n</code></pre> <ul> <li> <p><code>class FsmABCF extends Component</code>: Define um componente chamado <code>FsmABCF</code>.</p> </li> <li> <p><code>val io = new Bundle { ... }</code>: Cria um bundle de entradas e sa\u00eddas para o componente.</p> </li> <li> <p><code>val estadoReg = RegInit(U(1, 3 bits))</code>: Declara um registrador de estado inicializado para o estado A (1).</p> </li> <li> <p><code>switch(estadoReg) { ... }</code>: Implementa a l\u00f3gica da m\u00e1quina de estados, definindo as transi\u00e7\u00f5es entre os estados com base na entrada <code>ctrl</code>.</p> </li> </ul>"},{"location":"chisel/chisel-info/","title":"Chisel","text":""},{"location":"chisel/chisel-info/#do-chisel-ao-verilog-o-fluxo-de-geracao-de-hardware","title":"Do Chisel ao Verilog: o fluxo de gera\u00e7\u00e3o de hardware","text":"<p>O Chisel \u00e9 uma linguagem de descri\u00e7\u00e3o de hardware embedded em Scala, ou seja, todo c\u00f3digo escrito em Chisel \u00e9, na pr\u00e1tica, um programa Scala que, quando executado, constr\u00f3i uma \u00e1rvore de hardware em mem\u00f3ria. Esse processo funciona em diferentes etapas.</p>"},{"location":"chisel/chisel-info/#1-escrita-do-codigo-em-chisel-scala","title":"1. Escrita do c\u00f3digo em Chisel (Scala)","text":"<p>Na etapa de escrita do c\u00f3digo, o desenvolvedor descreve m\u00f3dulos, entradas, sa\u00eddas e l\u00f3gica combinacional ou sequencial usando classes e objetos Scala. Um exemplo simples seria um somador parametriz\u00e1vel, definido como uma classe que herda de <code>Module</code> e especifica seu <code>io</code>.</p>"},{"location":"chisel/chisel-info/#2-elaboracao-elaboration","title":"2. Elabora\u00e7\u00e3o (Elaboration)","text":"<p>Em seguida, ocorre a elabora\u00e7\u00e3o (elaboration). Quando o programa Scala \u00e9 executado (via <code>sbt run</code> ou um teste), o Chisel interpreta a constru\u00e7\u00e3o do hardware e gera uma representa\u00e7\u00e3o intermedi\u00e1ria chamada FIRRTL (Flexible Intermediate Representation for RTL). Nesse ponto, o hardware j\u00e1 est\u00e1 descrito em n\u00edvel de registradores e conex\u00f5es, mas ainda de forma mais abstrata que o Verilog.</p>"},{"location":"chisel/chisel-info/#3-transformacoes-em-firrtl","title":"3. Transforma\u00e7\u00f5es em FIRRTL","text":"<p>O compilador FIRRTL aplica ent\u00e3o uma s\u00e9rie de transforma\u00e7\u00f5es e otimiza\u00e7\u00f5es, que incluem verifica\u00e7\u00f5es de tipo, simplifica\u00e7\u00e3o de express\u00f5es e infer\u00eancia de larguras de sinais. Esse processo garante que o circuito seja consistente, sem ambiguidades e pronto para s\u00edntese.</p>"},{"location":"chisel/chisel-info/#4-emissao-de-verilog-backend","title":"4. Emiss\u00e3o de Verilog (Backend)","text":"<p>Ap\u00f3s esses passes, o FIRRTL \u00e9 convertido em Verilog RTL, a linguagem padr\u00e3o compreendida pelas ferramentas de s\u00edntese de FPGA e ASIC. O c\u00f3digo gerado est\u00e1 pronto para ser utilizado em simuladores Verilog, como o Verilator, ou em ferramentas de s\u00edntese como Quartus, Vivado, Synopsys e Cadence.</p>"},{"location":"chisel/chisel-info/#5-integracao-com-fluxo-de-sintese","title":"5. Integra\u00e7\u00e3o com fluxo de s\u00edntese","text":"<p>Por fim, o Verilog gerado pode ser integrado ao fluxo de s\u00edntese. Ele pode ser simulado para valida\u00e7\u00e3o funcional, sintetizado para FPGA (mapeado em LUTs, flip-flops e blocos DSP) ou para ASIC (mapeado em portas da biblioteca de c\u00e9lulas padr\u00e3o).</p> <p>Em resumo, o fluxo consiste em escrever o c\u00f3digo em Scala/Chisel, executar o programa para gerar FIRRTL, aplicar as transforma\u00e7\u00f5es necess\u00e1rias e emitir Verilog pronto para uso em fluxos de FPGA e ASIC.</p>"},{"location":"chisel/chisel-info/#beneficios-do-uso-de-uma-linguagem-de-alto-nivel","title":"Benef\u00edcios do uso de uma linguagem de alto n\u00edvel","text":"<p>O uso de uma linguagem de descri\u00e7\u00e3o de hardware de alto n\u00edvel como o Chisel traz benef\u00edcios significativos em compara\u00e7\u00e3o \u00e0s HDLs tradicionais.  </p> <p>Uma das principais vantagens \u00e9 que grande parte da complexidade de projeto pode ser tratada ainda na fase de elabora\u00e7\u00e3o, antes da gera\u00e7\u00e3o do Verilog. Nesse est\u00e1gio, o desenvolvedor pode explorar recursos como parametriza\u00e7\u00e3o, reuso de c\u00f3digo, composi\u00e7\u00e3o modular e at\u00e9 mesmo metaprograma\u00e7\u00e3o em Scala para descrever circuitos de forma mais abstrata e expressiva.  </p> <p>Um exemplo emblem\u00e1tico \u00e9 o Diplomacy, utilizado no ecossistema Chipyard. Esse recurso resolve automaticamente a configura\u00e7\u00e3o e interconex\u00e3o de barramentos complexos como TileLink, ajustando larguras, protocolos e topologias sem que o projetista precise lidar diretamente com fios e sinais de baixo n\u00edvel.  </p> <p>Dessa forma, o projetista trabalha em um n\u00edvel conceitual mais pr\u00f3ximo da arquitetura do sistema, enquanto o compilador Chisel/FIRRTL se encarrega de expandir essas descri\u00e7\u00f5es em Verilog detalhado. O resultado \u00e9 uma redu\u00e7\u00e3o significativa de erros, maior rapidez na explora\u00e7\u00e3o de alternativas de projeto e a possibilidade de construir sistemas complexos de maneira mais eficiente e confi\u00e1vel.</p> <p>Outro benef\u00edcio importante est\u00e1 na separa\u00e7\u00e3o clara entre a descri\u00e7\u00e3o do comportamento e a elabora\u00e7\u00e3o do hardware. Ao projetista cabe descrever o que o circuito deve fazer em um n\u00edvel mais abstrato, usando a linguagem de alto n\u00edvel para capturar a l\u00f3gica e a estrutura do sistema. \u00c0 ferramenta especializada (FIRRTL e backends do Chisel) cabe a tarefa de como gerar o Verilog final, aplicando otimiza\u00e7\u00f5es, infer\u00eancias de largura e transforma\u00e7\u00f5es que muitas vezes seriam trabalhosas ou propensas a erro se feitas manualmente. </p> <p>Dessa forma, o Verilog produzido tende a ser mais consistente, otimizado e menos sujeito a falhas humanas, permitindo que o projetista concentre esfor\u00e7os no comportamento funcional e arquitetural, enquanto a ferramenta assegura uma implementa\u00e7\u00e3o robusta em baixo n\u00edvel.</p> <p>Motiva\u00e7\u00e3o \u27f6</p>"},{"location":"chisel/introducao/","title":"CHISEL TUTORIAL","text":""},{"location":"chisel/introducao/#1-introducao","title":"1. Introdu\u00e7\u00e3o","text":"<p>Uma linguagem de descri\u00e7\u00e3o de hardware (HDL \u2013 Hardware Description Language) \u00e9 uma ferramenta que permite especificar circuitos digitais por meio de c\u00f3digo textual, descrevendo tanto a estrutura (como portas l\u00f3gicas, registradores e conex\u00f5es) quanto o comportamento (como opera\u00e7\u00f5es sequenciais e combinacionais) de um sistema. </p> <p>Tradicionalmente, linguagens como VHDL e Verilog dominaram esse espa\u00e7o, mas com o avan\u00e7o das metodologias de projeto surgiu a necessidade de ferramentas mais expressivas e integr\u00e1veis ao ecossistema de software moderno. </p> <p>\u00c9 nesse contexto que surge o Chisel (Constructing Hardware In a Scala Embedded Language), uma linguagem de descri\u00e7\u00e3o de hardware de alto n\u00edvel baseada em Scala, que permite descrever circuitos de forma concisa, parametriz\u00e1vel e reutiliz\u00e1vel. </p> <p>O Chisel combina a expressividade da programa\u00e7\u00e3o funcional e orientada a objetos com a precis\u00e3o necess\u00e1ria para gerar RTL em Verilog, oferecendo um fluxo de trabalho poderoso tanto para pesquisa acad\u00eamica quanto para desenvolvimento industrial.</p>"},{"location":"chisel/introducao/#2-chisel","title":"2. Chisel","text":"<p>Para informa\u00e7\u00f5es mais aprofundadas, consulte a p\u00e1gina Chisel.</p>"},{"location":"chisel/introducao/#3-motivacao","title":"3. Motiva\u00e7\u00e3o","text":"<p>Caso queira entender melhor a motiva\u00e7\u00e3o do tema de sistemas lineares no contexto deste tutorial, acesse a p\u00e1gina Motivacao.</p>"},{"location":"chisel/introducao/#4-repositorio","title":"4. Reposit\u00f3rio","text":"<p>Todo o material deste tutorial est\u00e1 reunido em um reposit\u00f3rio, que inclui os c\u00f3digos-fonte em Chisel, testbenches e instru\u00e7\u00f5es de execu\u00e7\u00e3o.</p>"},{"location":"chisel/introducao/#5-o-tutorial-realmente-existe","title":"5. O tutorial realmente existe??","text":"<p>Com isso, finalizamos a contextualiza\u00e7\u00e3o e a prepara\u00e7\u00e3o do ambiente. O tutorial efetivo inicia-se na p\u00e1gina Somadores, onde come\u00e7aremos a explorar na pr\u00e1tica a implementa\u00e7\u00e3o de circuitos digitais em Chisel.</p> <p>Chisel \u27f6</p>"},{"location":"chisel/motivacao/","title":"Motiva\u00e7\u00e3o","text":""},{"location":"chisel/motivacao/#sistemas-lineares","title":"Sistemas Lineares","text":"<p>A resolu\u00e7\u00e3o de sistemas lineares \u00e9 um problema cl\u00e1ssico em ci\u00eancia e engenharia, e sua implementa\u00e7\u00e3o em hardware envolve a utiliza\u00e7\u00e3o de diversas estruturas fundamentais. Ao explorar esse problema, \u00e9 poss\u00edvel abordar de forma pr\u00e1tica os principais blocos que comp\u00f5em circuitos digitais e entender como eles se organizam em arquiteturas mais complexas.  </p> <p>Em primeiro lugar, opera\u00e7\u00f5es b\u00e1sicas como soma e subtra\u00e7\u00e3o podem ser mapeadas em circuitos combinacionais, servindo de exemplo inicial para entender a constru\u00e7\u00e3o de operadores aritm\u00e9ticos e como eles se conectam em m\u00f3dulos maiores. Na sequ\u00eancia, opera\u00e7\u00f5es mais elaboradas como multiplica\u00e7\u00e3o e divis\u00e3o exigem a presen\u00e7a de circuitos sequenciais, que introduzem o conceito de lat\u00eancia, temporiza\u00e7\u00e3o e controle de dados ao longo do tempo.  </p> <p>Al\u00e9m disso, ao se utilizar m\u00e1quinas de estado finitas (FSMs) para organizar m\u00e9todos diretos ou iterativos de solu\u00e7\u00e3o, o estudante tem contato com uma das estruturas mais importantes em projeto digital, respons\u00e1vel por controlar o fluxo de execu\u00e7\u00e3o e coordenar as diferentes etapas de c\u00e1lculo. Esse ponto \u00e9 particularmente relevante quando se considera a implementa\u00e7\u00e3o de algoritmos de solu\u00e7\u00e3o iterativa, como m\u00e9todos de Jacobi ou Gauss-Seidel.  </p> <p>Outro aspecto motivador \u00e9 que a solu\u00e7\u00e3o de sistemas lineares envolve opera\u00e7\u00f5es que tamb\u00e9m aparecem em processadores modernos, como o uso de opera\u00e7\u00f5es em ponto flutuante, manipula\u00e7\u00e3o de vetores para representar equa\u00e7\u00f5es, e sinais de controle que coordenam a execu\u00e7\u00e3o em arquiteturas mais sofisticadas. Assim, o estudo desse problema permite n\u00e3o apenas praticar a constru\u00e7\u00e3o de m\u00f3dulos de hardware isolados, mas tamb\u00e9m visualizar como esses blocos est\u00e3o presentes em projetos reais de CPUs, GPUs e aceleradores de prop\u00f3sito espec\u00edfico.  </p> <p>Por fim, ao longo deste tutorial utilizaremos exemplos reais de classes implementadas no processador Rocket, n\u00e3o apenas para nos familiarizar com a descri\u00e7\u00e3o de hardware em Chisel, mas tamb\u00e9m para desenvolver a capacidade de ler e entender como projetos s\u00e9rios e amplamente utilizados na academia e na ind\u00fastria aplicam a linguagem na constru\u00e7\u00e3o de hardware complexo.</p>"},{"location":"chisel/motivacao/#exploracao-do-problema","title":"Explora\u00e7\u00e3o do problema","text":"\\[ \\begin{bmatrix} a_{11} &amp; a_{12} \\\\ a_{21} &amp; a_{22} \\end{bmatrix} \\cdot \\begin{bmatrix} x_{1} \\\\ x_{2} \\end{bmatrix} = \\begin{bmatrix} f_{1} \\\\ f_{2} \\end{bmatrix} \\;\\;\\Longrightarrow\\;\\; \\begin{bmatrix} a_{11} &amp; a_{12} \\\\ 0      &amp; a'_{22} \\end{bmatrix} \\cdot \\begin{bmatrix} x_{1} \\\\ x_{2} \\end{bmatrix} = \\begin{bmatrix} f_{1} \\\\ f'_{2} \\end{bmatrix} \\] \\[ \\begin{aligned} m_{21} &amp;= \\tfrac{a_{21}}{a_{11}} &amp;\\qquad x_2 &amp;= \\tfrac{f'_2}{a'_{22}} \\\\ a'_{22} &amp;= a_{22} - m_{21}a_{12} &amp;\\qquad x_1 &amp;= \\tfrac{f_1 - a_{12}x_2}{a_{11}} \\\\ f'_2 &amp;= f_2 - m_{21}f_1 \\end{aligned} \\] <p>O m\u00e9todo direto aplicado aqui \u00e9 a elimina\u00e7\u00e3o gaussiana, que funciona eliminando uma vari\u00e1vel a cada itera\u00e7\u00e3o at\u00e9 transformar o sistema em uma forma triangular superior. A partir desse formato, a solu\u00e7\u00e3o \u00e9 obtida por retrossubstitui\u00e7\u00e3o. No caso do sistema 2\u00d72 mostrado acima, \u00e9 necess\u00e1ria apenas uma itera\u00e7\u00e3o para eliminar a vari\u00e1vel \\(a_{21}\\), reduzindo o problema a duas equa\u00e7\u00f5es simples. Assim, a resolu\u00e7\u00e3o completa se resume a calcular as express\u00f5es de \\(x_2\\) e \\(x_1\\) apresentadas, evidenciando como opera\u00e7\u00f5es b\u00e1sicas de divis\u00e3o, multiplica\u00e7\u00e3o e subtra\u00e7\u00e3o permitem encontrar a solu\u00e7\u00e3o final. Al\u00e9m disso, as solu\u00e7\u00f5es do sistema podem ser analisadas pelo determinante de \\(A\\): se \\(\\det(A) \\neq 0\\), existe exatamente uma solu\u00e7\u00e3o; caso contr\u00e1rio, \\(\\det(A) = 0\\) implica que \\(a'_{22} = 0\\), o que leva a um sistema singular sem solu\u00e7\u00e3o \u00fanica.</p> <p>Nota: Nesta breve explora\u00e7\u00e3o assumimos que os piv\u00f4s nunca s\u00e3o nulos, de modo que n\u00e3o h\u00e1 necessidade de realizar pivotamento.</p> <p>Come\u00e7o do Tutorial \u27f6</p>"},{"location":"chisel/somadores/","title":"Somadores e Subtratores","text":""},{"location":"chisel/somadores/#4-somadores-e-subtratores","title":"4. Somadores e Subtratores","text":""},{"location":"chisel/somadores/#41-somadores-de-1-bit-a-16-bits","title":"4.1 Somadores de 1 bit a 16 bits","text":"<p>Para iniciar a explora\u00e7\u00e3o pr\u00e1tica em Chisel, vamos construir um somador a partir do bloco mais b\u00e1sico: o Full Adder (somador completo de 1 bit). Em seguida, mostraremos como reutilizar esse bloco para formar um somador de 16 bits.</p> <p>O c\u00f3digo em Chisel se assemelha a uma mistura entre Scala (linguagem de alto n\u00edvel) e operadores de hardware. Cada parte do c\u00f3digo tem um papel espec\u00edfico na descri\u00e7\u00e3o do circuito.</p> <pre><code>// Defini\u00e7\u00e3o de um somador completo de 1 bit\nclass FullAdder extends Module {\n  // A palavra-chave \"extends Module\" indica que essa classe descreve um m\u00f3dulo de hardware\n  val io = IO(new Bundle {\n    // Entradas: dois bits (a e b) e um bit de carry-in (cin)\n    val a    = Input(Bool())\n    val b    = Input(Bool())\n    val cin  = Input(Bool())\n    // Sa\u00eddas: soma (sum) e carry-out (cout)\n    val sum  = Output(Bool())\n    val cout = Output(Bool())\n  })\n\n  // Descri\u00e7\u00e3o da l\u00f3gica: XOR para a soma\n  io.sum  := io.a ^ io.b ^ io.cin\n  // Express\u00e3o booleana para o carry-out\n  io.cout := (io.a &amp; io.b) | (io.a &amp; io.cin) | (io.b &amp; io.cin)\n}\n</code></pre> <ul> <li><code>class FullAdder</code> cria uma nova classe que representa o circuito.  </li> <li><code>extends Module</code> indica que essa classe descreve um m\u00f3dulo de hardware em Chisel.  </li> <li><code>val io = IO(new Bundle {...})</code> define as portas de entrada e sa\u00edda do m\u00f3dulo.  </li> <li><code>Input(Bool())</code> e <code>Output(Bool())</code> representam fios de 1 bit.  </li> <li>Os operadores <code>^</code>, <code>&amp;</code> e <code>|</code> descrevem l\u00f3gica combinacional (XOR, AND, OR).  </li> <li>O s\u00edmbolo <code>:=</code> \u00e9 usado para conectar sinais em Chisel (atribui\u00e7\u00e3o de hardware).  </li> </ul> <p>A partir desse bloco b\u00e1sico, podemos montar um somador de 16 bits, encadeando 16 inst\u00e2ncias do <code>FullAdder</code>.</p> <pre><code>// Somador de 16 bits constru\u00eddo a partir de FullAdders\nclass Adder16 extends Module {\n  val io = IO(new Bundle {\n    val a   = Input(UInt(16.W))   // entrada de 16 bits\n    val b   = Input(UInt(16.W))   // entrada de 16 bits\n    val cin = Input(Bool())       // carry-in inicial\n    val sum = Output(UInt(16.W))  // sa\u00edda de 16 bits\n    val cout= Output(Bool())      // carry-out final\n  })\n\n  // Vetores auxiliares (wires) para propagar os valores de soma e carry\n  val sums  = Wire(Vec(16, Bool()))\n  val carry = Wire(Vec(17, Bool()))\n  carry(0) := io.cin\n\n  // Instancia 16 Full Adders, um para cada bit\n  for (i &lt;- 0 until 16) {\n    val fa = Module(new FullAdder())\n    fa.io.a   := io.a(i)\n    fa.io.b   := io.b(i)\n    fa.io.cin := carry(i)\n    sums(i)   := fa.io.sum\n    carry(i+1):= fa.io.cout\n  }\n\n  // Conecta o resultado final\n  io.sum  := sums.asUInt\n  io.cout := carry(16)\n}\n</code></pre> <ul> <li><code>UInt(16.W)</code> define um fio com largura de 16 bits.  </li> <li><code>Wire(Vec(...))</code> cria vetores de sinais intermedi\u00e1rios, aqui usados para armazenar somas e a propaga\u00e7\u00e3o do carry.  </li> <li><code>for (i &lt;- 0 until 16)</code> mostra como Chisel permite usar estruturas de controle da linguagem Scala para gerar hardware repetitivo, evitando escrever manualmente 16 inst\u00e2ncias de <code>FullAdder</code>.  </li> <li>A fun\u00e7\u00e3o <code>asUInt</code> converte o vetor de bits individuais em um \u00fanico sinal de 16 bits.  </li> </ul>"},{"location":"chisel/somadores/#42-somadores-completos-parametrizados","title":"4.2 Somadores completos parametrizados","text":"<p>No somador de 16 bits, a largura era fixa no c\u00f3digo. Para torn\u00e1-lo mais flex\u00edvel, podemos parametrizar o n\u00famero de bits utilizando um argumento na defini\u00e7\u00e3o da classe. Assim, o mesmo c\u00f3digo pode gerar somadores de qualquer largura.</p> <pre><code>class Adder(val nBits: Int) extends Module {\n</code></pre> <p>Nesta linha a largura do somador passa a ser definida pelo par\u00e2metro nBits, informado na instancia\u00e7\u00e3o do m\u00f3dulo, em vez de estar fixada em 16 bits.</p> <pre><code>val sums  = Wire(Vec(nBits, Bool()))\nval carry = Wire(Vec(nBits + 1, Bool()))\n</code></pre> <p>Aqui os vetores auxiliares sums e carry assumem tamanhos vari\u00e1veis de acordo com nBits. O vetor carry precisa de uma posi\u00e7\u00e3o extra, j\u00e1 que a propaga\u00e7\u00e3o do carry gera uma sa\u00edda adicional.</p> <pre><code>for (i &lt;- 0 until nBits) {\n</code></pre> <p>O la\u00e7o de repeti\u00e7\u00e3o percorre exatamente nBits posi\u00e7\u00f5es, instanciando automaticamente o n\u00famero correto de FullAdders conforme a largura especificada.</p> <p>Para instanciar um somador de 32 bits a partir da classe parametrizada, basta escrever:</p> <pre><code>val adder32 = Module(new Adder(32))\n</code></pre>"},{"location":"chisel/somadores/#43-operadores-aritmeticos-de-alto-nivel","title":"4.3 Operadores Aritm\u00e9ticos de Alto N\u00edvel","text":"<p>Um ponto importante a destacar \u00e9 o uso preferencial dos operadores de alto n\u00edvel, como <code>+</code> e <code>-</code>, para implementar soma e subtra\u00e7\u00e3o. Em FPGAs, esses operadores s\u00e3o automaticamente mapeados pelas ferramentas de s\u00edntese em blocos internos altamente otimizados, como carry chains e unidades aritm\u00e9ticas dedicadas, que fazem parte da l\u00f3gica intr\u00ednseca do dispositivo. Isso garante implementa\u00e7\u00f5es eficientes em termos de \u00e1rea e desempenho, sem exigir que o projetista especifique manualmente a arquitetura do somador. J\u00e1 no caso de ASICs, a situa\u00e7\u00e3o \u00e9 diferente: n\u00e3o existem blocos aritm\u00e9ticos pr\u00e9-definidos, sendo necess\u00e1rio escolher explicitamente a arquitetura a ser utilizada (ripple-carry, carry-lookahead, Kogge-Stone, entre outras). Essa escolha envolve um trade-off complexo entre \u00e1rea, lat\u00eancia e consumo de energia, e abre espa\u00e7o para uma discuss\u00e3o muito mais profunda \u2014 que foge ao escopo deste tutorial.</p> <p>A partir deste ponto, utilizaremos preferencialmente os operadores aritm\u00e9ticos de alto n\u00edvel (<code>+</code> e <code>-</code>) para implementar somadores e subtratores. Por exemplo, a classe <code>CombParamSInt</code> pode ser vista como uma vers\u00e3o avan\u00e7ada do uso direto de <code>+</code> e <code>-</code>, pois al\u00e9m de realizar soma e subtra\u00e7\u00e3o, tamb\u00e9m verifica automaticamente se houve overflow durante as opera\u00e7\u00f5es.</p> <pre><code>  val aExt = io.a.pad(nBits + 1) // SInt(nBits+1)\n  val sumWide = Wire(SInt((nBits + 1).W))\n  sumWide := aExt +&amp; bExt\n  io.OutSum      := sumWide(nBits - 1, 0).asSInt\n  io.addOverflow := (sumWide(nBits) ^ sumWide(nBits - 1)).asBool\n</code></pre> <ul> <li> <p><code>pad(nBits + 1)</code>   Extende o operando <code>SInt</code> em 1 bit adicional, preservando o sinal (sign-extend). Isso cria \u201cfolga\u201d para capturar corretamente situa\u00e7\u00f5es de overflow sem perder o bit de sinal.  </p> </li> <li> <p><code>Wire(SInt((nBits + 1).W))</code>   Cria um fio tempor\u00e1rio (<code>sumWide</code>) com largura expandida em nBits + 1, onde ser\u00e1 armazenado o resultado da opera\u00e7\u00e3o antes de ser truncado.  </p> </li> <li> <p><code>+&amp;</code> (soma com expans\u00e3o)   Diferente do operador <code>+</code>, o <code>+&amp;</code> preserva o bit extra gerado pela opera\u00e7\u00e3o, garantindo que o resultado n\u00e3o perca a informa\u00e7\u00e3o de overflow.  </p> </li> <li> <p><code>sumWide(nBits - 1, 0).asSInt</code>   Seleciona apenas os nBits menos significativos do resultado expandido, convertendo de volta para o tamanho original do m\u00f3dulo. Esse \u00e9 o valor real da soma que ser\u00e1 exposto em <code>io.OutSum</code>.  </p> </li> <li> <p><code>(sumWide(nBits) ^ sumWide(nBits - 1)).asBool</code>   Faz o XOR entre os dois bits mais significativos do resultado (<code>MSB extra</code> e <code>MSB real</code>), t\u00e9cnica padr\u00e3o para detec\u00e7\u00e3o de overflow em opera\u00e7\u00f5es com sinal. O resultado l\u00f3gico (<code>Bool</code>) \u00e9 disponibilizado em <code>io.addOverflow</code>.</p> </li> </ul>"}]}